<!DOCTYPE html>
<html>
<head>
    <title>H264 Streamer Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        @keyframes tl-blink { 0%,100%{opacity:1} 50%{opacity:0.2} }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { color: #4CAF50; }
        .section { background: #2d2d2d; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .section h2 { margin-top: 0; color: #888; font-size: 14px; text-transform: uppercase; }
        .row { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; }
        .label { color: #ccc; }
        /* Settings layout - controls aligned right, centered content */
        #settings-form { padding: 0 12%; }
        .setting { margin-bottom: 18px; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; gap: 30px; }
        .setting-row .label { flex-shrink: 0; white-space: nowrap; }
        .setting-row .control { display: flex; align-items: center; gap: 10px; justify-content: flex-end; }
        .setting-row .slider-control { display: flex; align-items: center; gap: 10px; flex: 1; max-width: 320px; }
        .setting-row .slider-control input[type="range"] { flex: 1; min-width: 200px; }
        .setting-note { text-align: right; color: #888; font-size: 12px; margin-top: 6px; }
        .value { color: #4CAF50; font-weight: bold; }
        button { background: #4CAF50; color: white; border: none; padding: 10px 20px;
                  border-radius: 4px; cursor: pointer; font-size: 14px; margin: 2px; }
        button:hover { background: #45a049; }
        button.secondary { background: #555; }
        button.secondary:hover { background: #666; }
        button.danger { background: #f44336; }
        button.danger:hover { background: #da190b; }
        input[type="number"] { width: 60px; padding: 8px; border-radius: 4px; border: 1px solid #555;
                                background: #333; color: #fff; }
        .toggle { position: relative; display: inline-block; width: 50px; height: 26px; }
        .toggle input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
                   background-color: #555; transition: .3s; border-radius: 26px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px;
                         bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; }
        input:checked + .slider { background-color: #4CAF50; }
        input:checked + .slider:before { transform: translateX(24px); }
        .preview { margin: 10px 0; }
        .preview img, .preview video { max-width: 100%; border-radius: 4px; background: #000; }
        .links a { color: #4CAF50; margin-right: 15px; }
        #cpu-stats { font-family: monospace; }
        .tabs { display: flex; gap: 5px; margin-bottom: 10px; }
        .tabs button { flex: 1; }
        .tabs button.active { background: #4CAF50; }
        .tabs button.active::before { content: '\25CF'; margin-right: 6px; }
        .camera-selector { display: flex; gap: 5px; margin: 10px 0; flex-wrap: wrap; }
        .camera-selector button { padding: 4px 10px; font-size: 12px; background: #2563eb; border: none; border-radius: 4px; color: #fff; cursor: pointer; }
        .camera-selector button:hover { background: #1d4ed8; }
        .camera-selector button.active { background: #1e40af; box-shadow: 0 0 0 2px #60a5fa; }
        .camera-selector button.active::before { content: '\25CF'; margin-right: 4px; }
        .camera-selector button:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }
        .camera-selector button:disabled:hover { background: #555; }
        .cam-enable-toggle { display: inline-block; vertical-align: middle; margin-left: 4px; cursor: pointer; padding: 4px 8px; border-radius: 4px; background: #444; color: #888; font-size: 11px; font-weight: bold; border: 1px solid #555; }
        .cam-enable-toggle:hover { background: #555; color: #fff; border-color: #666; }
        .cam-enable-toggle.enabled { background: #1a5c2e; color: #4CAF50; border-color: #2d7a45; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .stat-box { background: #222; padding: 10px; border-radius: 4px; text-align: center; }
        .stat-value { font-size: 24px; color: #4CAF50; font-weight: bold; }
        .stat-label { font-size: 12px; color: #888; }
        #flv-player { width: 100%; max-height: 480px; }
        .player-controls { margin-top: 10px; }
        .stream-overlay { position:absolute; top:6px; left:6px; background:rgba(0,0,0,0.7); color:#ccc; font-size:11px; font-family:monospace; padding:3px 7px; border-radius:3px; pointer-events:none; z-index:5; line-height:1.4; }
        .stream-overlay.error { color:#f44; }
        /* Loading overlay for restart */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .loading-overlay.active { display: flex; }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            margin-top: 20px;
            color: #4CAF50;
            font-size: 18px;
        }
        .loading-status {
            margin-top: 10px;
            color: #888;
            font-size: 14px;
        }
        /* Camera controls */
        .camera-controls-section h2 {
            margin-bottom: 10px;
        }
        .camera-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .cam-ctrl-group {
            background: #252525;
            padding: 15px;
            border-radius: 6px;
        }
        .cam-ctrl-group h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #4CAF50;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .cam-ctrl {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        .cam-ctrl label {
            flex: 0 0 100px;
            font-size: 12px;
            color: #aaa;
        }
        .cam-ctrl input[type="range"] {
            flex: 1;
            height: 6px;
            background: #444;
            border-radius: 3px;
            -webkit-appearance: none;
            appearance: none;
        }
        .cam-ctrl input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        .cam-ctrl input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .cam-ctrl span {
            flex: 0 0 50px;
            text-align: right;
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }
        .cam-ctrl select {
            flex: 1;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- Loading overlay for restart -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Restarting H264 Streamer...</div>
        <div class="loading-status" id="loading-status">Saving settings...</div>
    </div>

    <div class="container">
        <h1 style="font-size:22px;margin-bottom:10px;">H264 Streamer Control <span style="font-size:13px;color:#888;font-weight:normal;">streamer v$streamer_version / encoder v$encoder_version</span></h1>

        <div class="section">
            <h2 style="display:inline;">Live Preview</h2>
            <span style="color:#f44;font-size:12px;margin-left:15px;background:#411;padding:4px 8px;border-radius:4px;">WARNING: Debug tool - increases CPU usage, do not leave open!</span>
            <div id="camera-selector" class="camera-selector" style="display:none;"></div>
            <div id="camera-status-panel" style="display:none;background:#1a1a1a;padding:8px;border-radius:4px;margin:5px 0;"></div>
            <div class="tabs">
                <button class="active" onclick="switchTab('snapshot')">Snapshot</button>
                <button onclick="switchTab('mjpeg')">MJPEG Stream</button>
                <button onclick="switchTab('flv')">H.264 Stream</button>
                <button onclick="switchTab('display')">Display</button>
            </div>
            <div class="preview">
                <div id="tab-snapshot" class="tab-content active">
                    <img src="/snapshot" id="preview-img" onclick="this.src='/snapshot?'+Date.now()">
                    <p style="color:#888;font-size:12px">Click image to refresh</p>
                </div>
                <div id="tab-mjpeg" class="tab-content" style="position:relative;">
                    <img id="mjpeg-stream" style="display:none">
                    <div id="mjpeg-overlay" class="stream-overlay" style="display:none"></div>
                    <p style="color:#888;font-size:12px">Live MJPEG stream</p>
                </div>
                <div id="tab-flv" class="tab-content" style="position:relative;">
                    <video id="flv-player" muted autoplay></video>
                    <div id="flv-overlay" class="stream-overlay" style="display:none"></div>
                    <div class="player-controls">
                        <button onclick="startFlvPlayer()">Play</button>
                        <button class="secondary" onclick="stopFlvPlayer()">Stop</button>
                        <span id="flv-status" style="margin-left:10px;color:#888;"></span>
                    </div>
                </div>
                <div id="tab-display" class="tab-content">
                    <img id="display-stream" style="display:none">
                    <p style="color:#888;font-size:12px">Printer LCD framebuffer - Click to touch</p>
                </div>
            </div>
            <div style="margin-top:10px;display:flex;justify-content:space-between;align-items:center;">
                <div style="display:flex;gap:5px;">
                    <button onclick="window.open(mjpegUrl, '_blank')" class="secondary" style="padding:5px 12px;font-size:12px;">Open MJPEG</button>
                    <button onclick="window.open(snapshotUrl, '_blank')" class="secondary" style="padding:5px 12px;font-size:12px;">Open Snapshot</button>
                    <button onclick="openFlvFullscreen()" class="secondary" style="padding:5px 12px;font-size:12px;">Open FLV</button>
                    <button onclick="window.open(streamBase + '/display', '_blank')" class="secondary" style="padding:5px 12px;font-size:12px;">Open Display</button>
                    <button onclick="window.open('/timelapse', 'timelapse_' + location.hostname.replace(/\./g, '_'), 'width=900,height=700')" class="secondary" style="padding:5px 12px;font-size:12px;"><span id="tl-encode-dot" style="display:none;margin-right:4px;font-size:10px;" title="">&#9679;</span>Time Lapse</button>
                </div>
                <div style="display:flex;gap:5px;align-items:center;">
                    <span style="color:#888;font-size:12px;margin-right:5px;">LED:</span>
                    <button id="led-on-btn" onclick="controlLed(true)" style="padding:5px 12px;font-size:12px;">On</button>
                    <button id="led-off-btn" onclick="controlLed(false)" class="secondary" style="padding:5px 12px;font-size:12px;">Off</button>
                </div>
            </div>
        </div>

        <div class="section camera-controls-section">
            <h2 onclick="toggleCameraControls()" style="cursor:pointer;user-select:none;">
                <span id="camera-controls-arrow">&#9654;</span> CAMERA CONTROLS
                <span style="font-size:12px;color:#888;font-weight:normal;margin-left:10px;">(click to expand)</span>
            </h2>
            <div id="camera-controls-panel" style="display:none;">
                <div class="camera-controls-grid">
                    <div class="cam-ctrl-group">
                        <h3>Image</h3>
                        <div class="cam-ctrl">
                            <label>Brightness</label>
                            <input type="range" id="cam-brightness" min="0" max="255" value="0" oninput="setCameraControl('brightness', this.value)">
                            <span id="cam-brightness-val">0</span>
                        </div>
                        <div class="cam-ctrl">
                            <label>Contrast</label>
                            <input type="range" id="cam-contrast" min="0" max="255" value="32" oninput="setCameraControl('contrast', this.value)">
                            <span id="cam-contrast-val">32</span>
                        </div>
                        <div class="cam-ctrl">
                            <label>Saturation</label>
                            <input type="range" id="cam-saturation" min="0" max="132" value="85" oninput="setCameraControl('saturation', this.value)">
                            <span id="cam-saturation-val">85</span>
                        </div>
                        <div class="cam-ctrl">
                            <label>Hue</label>
                            <input type="range" id="cam-hue" min="-180" max="180" value="0" oninput="setCameraControl('hue', this.value)">
                            <span id="cam-hue-val">0</span>
                        </div>
                        <div class="cam-ctrl">
                            <label>Gamma</label>
                            <input type="range" id="cam-gamma" min="90" max="150" value="100" oninput="setCameraControl('gamma', this.value)">
                            <span id="cam-gamma-val">100</span>
                        </div>
                        <div class="cam-ctrl">
                            <label>Sharpness</label>
                            <input type="range" id="cam-sharpness" min="0" max="30" value="3" oninput="setCameraControl('sharpness', this.value)">
                            <span id="cam-sharpness-val">3</span>
                        </div>
                    </div>
                    <div class="cam-ctrl-group">
                        <h3>Exposure</h3>
                        <div class="cam-ctrl">
                            <label>Auto Exposure</label>
                            <select id="cam-exposure-auto" onchange="setCameraControl('exposure_auto', this.value)">
                                <option value="1">Manual</option>
                                <option value="3" selected>Auto (Aperture Priority)</option>
                            </select>
                        </div>
                        <div class="cam-ctrl">
                            <label>Exposure</label>
                            <input type="range" id="cam-exposure" min="10" max="2500" value="156" oninput="setCameraControl('exposure', this.value)">
                            <span id="cam-exposure-val">156</span>
                        </div>
                        <div class="cam-ctrl">
                            <label>Exposure Priority</label>
                            <select id="cam-exposure-priority" onchange="setCameraControl('exposure_priority', this.value)">
                                <option value="0" selected>Constant FPS</option>
                                <option value="1">Variable FPS</option>
                            </select>
                        </div>
                        <div class="cam-ctrl">
                            <label>Gain</label>
                            <select id="cam-gain" onchange="setCameraControl('gain', this.value)">
                                <option value="0">Off</option>
                                <option value="1" selected>On</option>
                            </select>
                        </div>
                        <div class="cam-ctrl">
                            <label>Backlight Comp</label>
                            <input type="range" id="cam-backlight" min="0" max="7" value="0" oninput="setCameraControl('backlight', this.value)">
                            <span id="cam-backlight-val">0</span>
                        </div>
                    </div>
                    <div class="cam-ctrl-group">
                        <h3>White Balance</h3>
                        <div class="cam-ctrl">
                            <label>Auto WB</label>
                            <select id="cam-wb-auto" onchange="setCameraControl('wb_auto', this.value); updateWbTempState();">
                                <option value="0">Manual</option>
                                <option value="1" selected>Auto</option>
                            </select>
                        </div>
                        <div class="cam-ctrl">
                            <label>Temperature</label>
                            <input type="range" id="cam-wb-temp" min="2800" max="6500" value="4000" oninput="setCameraControl('wb_temp', this.value)">
                            <span id="cam-wb-temp-val">4000K</span>
                        </div>
                        <div class="cam-ctrl">
                            <label>Power Line</label>
                            <select id="cam-power-line" onchange="setCameraControl('power_line', this.value)">
                                <option value="0">Disabled</option>
                                <option value="1" selected>50 Hz</option>
                                <option value="2">60 Hz</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div style="margin-top:15px;text-align:center;">
                    <button type="button" onclick="resetCameraDefaults()" class="secondary" style="padding:8px 20px;">Reset to Defaults</button>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Performance</h2>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="stat-mjpeg-fps">-</div>
                    <div class="stat-label">MJPEG FPS</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="stat-h264-fps">-</div>
                    <div class="stat-label">H.264 FPS</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="stat-clients">0</div>
                    <div class="stat-label">Clients</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="stat-cpu-total">-</div>
                    <div class="stat-label">Total CPU</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="stat-cpu-encoder">-</div>
                    <div class="stat-label">Encoder CPU</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="stat-cpu-streamer">-</div>
                    <div class="stat-label">Secondary Encoders CPU</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Settings</h2>
            <form id="settings-form">
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Encoder Type:</span>
                        <div class="control">
                            <select name="encoder_type" id="encoder_type" onchange="handleEncoderChange(this)" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                <option value="rkmpi" $encoder_rkmpi_selected>rkmpi (HW MJPEG)</option>
                                <option value="rkmpi-yuyv" $encoder_rkmpi_yuyv_selected>rkmpi-yuyv (HW H.264)</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-note">Requires restart</div>
                </div>
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Auto Enable LAN Mode:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="autolanmode" $autolanmode_checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Debug Logging:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="logging" $logging_checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Log Max Size (KB):</span>
                        <div class="control">
                            <input type="number" name="log_max_size" value="$log_max_size" min="100" max="5120" step="1" style="width:80px">
                        </div>
                    </div>
                </div>
                <div class="setting rkmpi-mjpeg-only h264-local-setting">
                    <div class="setting-row">
                        <span class="label">H.264 Encoding:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="h264_enabled" $h264_enabled_checked onchange="updateStatusPorts()">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="setting rkmpi-mjpeg-only">
                    <div class="setting-row">
                        <span class="label">MJPEG Frame Rate:</span>
                        <div class="slider-control">
                            <input type="range" id="mjpeg_fps_slider" name="mjpeg_fps" min="2" max="$max_camera_fps" value="$mjpeg_fps"
                                   oninput="document.getElementById('mjpeg_fps_input').value=this.value;updateMjpegFpsLabel();">
                            <input type="number" id="mjpeg_fps_input" min="2" max="$max_camera_fps" value="$mjpeg_fps"
                                   style="width:50px;"
                                   oninput="document.getElementById('mjpeg_fps_slider').value=this.value;document.querySelector('[name=mjpeg_fps]').value=this.value;updateMjpegFpsLabel();">
                            <span>fps</span>
                        </div>
                    </div>
                    <div class="setting-note"><span id="mjpeg_fps_label"></span></div>
                </div>
                <div class="setting rkmpi-yuyv-only">
                    <div class="setting-row">
                        <span class="label">Moonraker FPS:</span>
                        <div class="slider-control">
                            <input type="range" id="mjpeg_fps_slider_yuyv" name="mjpeg_fps" min="2" max="30" value="$mjpeg_fps"
                                   oninput="document.getElementById('mjpeg_fps_input_yuyv').value=this.value;">
                            <input type="number" id="mjpeg_fps_input_yuyv" min="2" max="30" value="$mjpeg_fps"
                                   style="width:50px;"
                                   oninput="document.getElementById('mjpeg_fps_slider_yuyv').value=this.value;document.querySelector('[name=mjpeg_fps]').value=this.value;">
                            <span>fps</span>
                        </div>
                    </div>
                    <div class="setting-note">Only for Moonraker USB camera setup</div>
                </div>
                <div class="setting rkmpi-mjpeg-only h264-local-setting">
                    <div class="setting-row">
                        <span class="label">H.264 Frame Rate:</span>
                        <div class="slider-control">
                            <input type="range" id="fps_pct_slider" min="0" max="100" value="$fps_pct"
                                   oninput="document.getElementById('fps_pct_input').value=this.value;updateFpsLabel();savedSkipRatio=pctToSkipRatio(parseInt(this.value));">
                            <input type="number" id="fps_pct_input" min="0" max="100" value="$fps_pct"
                                   style="width:50px;"
                                   oninput="document.getElementById('fps_pct_slider').value=this.value;updateFpsLabel();savedSkipRatio=pctToSkipRatio(parseInt(this.value));">
                            <span>%</span>
                        </div>
                    </div>
                    <div class="setting-note"><span id="fps_label"></span></div>
                    <input type="hidden" name="skip_ratio" id="skip_ratio_hidden" value="$skip_ratio">
                </div>
                <div class="setting rkmpi-mjpeg-only h264-local-setting">
                    <div class="setting-row">
                        <span class="label">Auto Skip (CPU-based):</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="auto_skip" $auto_skip_checked onchange="toggleAutoSkip(this.checked);">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="setting rkmpi-mjpeg-only h264-local-setting">
                    <div class="setting-row">
                        <span class="label">Target CPU % (for auto-skip):</span>
                        <div class="control">
                            <input type="number" name="target_cpu" value="$target_cpu" min="25" max="90">
                        </div>
                    </div>
                </div>
                <div class="setting rkmpi-only h264-local-setting">
                    <div class="setting-row">
                        <span class="label">H.264 Bitrate (kbps):</span>
                        <div class="control">
                            <input type="number" name="bitrate" value="$bitrate" min="100" max="4000" style="width:80px;">
                        </div>
                    </div>
                </div>
                <div class="setting rkmpi-only">
                    <div class="setting-row">
                        <span class="label">Camera Resolution:</span>
                        <div class="control">
                            <select name="h264_resolution" id="camera_resolution" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                <option value="1280x720" $res_1280_selected>1280x720 (full)</option>
                                <option value="960x540" $res_960_selected>960x540 (scaled)</option>
                                <option value="640x360" $res_640_selected>640x360 (scaled)</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-note rkmpi-mjpeg-note">Lower resolution = less TurboJPEG decode CPU. Requires restart.</div>
                    <div class="setting-note rkmpi-yuyv-note" style="display:none;">Lower resolution = more FPS. Requires restart.</div>
                </div>
                <div class="setting rkmpi-only" style="border-top: 1px solid #444; padding-top: 15px; margin-top: 15px;">
                    <div class="setting-row">
                        <span class="label">Display Capture:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="display_enabled" $display_enabled_checked onchange="updateDisplaySettings()">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="setting-note">Capture printer LCD screen (full hardware acceleration)</div>
                </div>
                <div class="setting rkmpi-only">
                    <div class="setting-row">
                        <span class="label">Display FPS:</span>
                        <div class="control">
                            <select name="display_fps" id="display_fps_select" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                <option value="1" $dfps_1_selected>1 fps (lowest CPU)</option>
                                <option value="2" $dfps_2_selected>2 fps</option>
                                <option value="3" $dfps_3_selected>3 fps</option>
                                <option value="5" $dfps_5_selected>5 fps</option>
                                <option value="10" $dfps_10_selected>10 fps (highest)</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-note">Higher FPS = more CPU usage</div>
                </div>
                <div class="setting rkmpi-only" style="border-top: 1px solid #444; padding-top: 15px; margin-top: 15px;">
                    <div class="setting-row">
                        <span class="label">ACProxyCam FLV Proxy:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="acproxycam_flv_proxy" value="1" $acproxycam_flv_proxy_checked onchange="toggleProxySettings(this.checked)">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="setting-note">Offload H.264 encoding to ACProxyCam. Requires ACProxyCam with encoding enabled. Restarts encoder.</div>
                </div>
                <div class="setting" style="margin-top: 15px;">
                    <div class="setting-row">
                        <button type="submit">Apply Settings</button>
                        <span style="color:#f90;font-size:12px;">Note: Encoder type change requires app restart</span>
                    </div>
                </div>
            </form>
        </div>

        <div class="section rkmpi-only">
            <h2>Timelapse Settings</h2>
            <p style="color:#888;font-size:12px;margin-bottom:15px;">Independent timelapse recording via Moonraker integration. Records regardless of slicer settings.</p>
            <form id="timelapse-form">
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Enable Timelapse:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="timelapse_enabled" id="timelapse_enabled" $timelapse_enabled_checked onchange="updateTimelapseSettings()">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="setting-note">Auto-record timelapse for all prints via Moonraker</div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Mode:</span>
                        <div class="control">
                            <select name="timelapse_mode" id="timelapse_mode" onchange="updateTimelapseModeSettings()" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                <option value="layer" $timelapse_mode_layer_selected>Layer-based</option>
                                <option value="hyperlapse" $timelapse_mode_hyperlapse_selected>Hyperlapse (time-based)</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting hyperlapse-only" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Hyperlapse Interval:</span>
                        <div class="control">
                            <input type="number" name="timelapse_hyperlapse_interval" value="$timelapse_hyperlapse_interval" min="5" max="300" style="width:60px;">
                            <span style="margin-left:5px;">seconds</span>
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting" style="display:none; border-top: 1px solid #444; padding-top: 15px; margin-top: 15px;">
                    <div class="setting-row">
                        <span class="label">Storage Location:</span>
                        <div class="control">
                            <select name="timelapse_storage" id="timelapse_storage" onchange="updateStorageSettings()" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                <option value="internal" $timelapse_storage_internal_selected>Internal Flash</option>
                                <option value="usb" $timelapse_storage_usb_selected>USB Drive</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">USB Status:</span>
                        <div class="control">
                            <span id="usb_status" style="color:#888;">Checking...</span>
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting usb-path-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">USB Path:</span>
                        <div class="control" style="display:flex;gap:5px;">
                            <input type="text" name="timelapse_usb_path" id="timelapse_usb_path" value="$timelapse_usb_path" readonly style="flex:1;min-width:150px;padding:8px;border-radius:4px;border:1px solid #555;background:#222;color:#aaa;cursor:pointer;" onclick="openFolderPicker()" title="Click to browse">
                            <button type="button" onclick="openFolderPicker()" style="padding:8px 12px;cursor:pointer;" title="Browse folders">&#128193;</button>
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting" style="display:none; border-top: 1px solid #444; padding-top: 15px; margin-top: 15px;">
                    <div class="setting-row">
                        <span class="label">Output FPS:</span>
                        <div class="control">
                            <input type="number" name="timelapse_output_fps" value="$timelapse_output_fps" min="1" max="120" style="width:60px;">
                        </div>
                    </div>
                    <div class="setting-note">Video playback framerate</div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Variable FPS:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="timelapse_variable_fps" id="timelapse_variable_fps" $timelapse_variable_fps_checked onchange="updateVariableFpsSettings()">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="setting-note">Auto-adjust FPS to reach target video length</div>
                </div>
                <div class="setting timelapse-setting variable-fps-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Target Length:</span>
                        <div class="control">
                            <input type="number" name="timelapse_target_length" value="$timelapse_target_length" min="1" max="300" style="width:60px;">
                            <span style="margin-left:5px;">seconds</span>
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting variable-fps-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Min/Max FPS:</span>
                        <div class="control">
                            <input type="number" name="timelapse_variable_fps_min" value="$timelapse_variable_fps_min" min="1" max="60" style="width:50px;">
                            <span style="margin:0 5px;">/</span>
                            <input type="number" name="timelapse_variable_fps_max" value="$timelapse_variable_fps_max" min="1" max="120" style="width:50px;">
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Quality (CRF):</span>
                        <div class="control">
                            <input type="number" name="timelapse_crf" value="$timelapse_crf" min="0" max="51" style="width:60px;">
                        </div>
                    </div>
                    <div class="setting-note">0=lossless, 23=default, 51=worst</div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Duplicate Last Frame:</span>
                        <div class="control">
                            <input type="number" name="timelapse_duplicate_last_frame" value="$timelapse_duplicate_last_frame" min="0" max="60" style="width:60px;">
                        </div>
                    </div>
                    <div class="setting-note">Repeat final frame N times</div>
                </div>
                <div class="setting timelapse-setting" style="display:none; border-top: 1px solid #444; padding-top: 15px; margin-top: 15px;">
                    <div class="setting-row">
                        <span class="label">Stream Delay:</span>
                        <div class="control">
                            <input type="number" name="timelapse_stream_delay" value="$timelapse_stream_delay" min="0" max="5" step="0.01" style="width:60px;">
                            <span style="margin-left:5px;">seconds</span>
                        </div>
                    </div>
                    <div class="setting-note">Delay before capture to compensate for stream latency</div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">End Delay:</span>
                        <div class="control">
                            <input type="number" name="timelapse_end_delay" value="$timelapse_end_delay" min="0" max="30" step="0.5" style="width:60px;">
                            <span style="margin-left:5px;">seconds</span>
                        </div>
                    </div>
                    <div class="setting-note">Delay before final capture for head to park</div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Flip Horizontal:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="timelapse_flip_x" $timelapse_flip_x_checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="setting timelapse-setting" style="display:none;">
                    <div class="setting-row">
                        <span class="label">Flip Vertical:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" name="timelapse_flip_y" $timelapse_flip_y_checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="setting" style="margin-top: 15px;">
                    <div class="setting-row">
                        <button type="submit">Apply Timelapse Settings</button>
                    </div>
                </div>
            </form>
        </div>

        <div class="section">
            <h2>Moonraker Settings</h2>
            <p style="color:#888;font-size:12px;margin-bottom:15px;">Moonraker connection and camera provisioning for the dashboard and web UI.</p>
            <div style="padding: 0 12%;">
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Moonraker Host:</span>
                        <div class="control">
                            <input type="text" id="mr-settings-host" value="$moonraker_host" style="width:120px;padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                        </div>
                    </div>
                </div>
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Moonraker Port:</span>
                        <div class="control">
                            <input type="number" id="mr-settings-port" value="$moonraker_port" min="1" max="65535" style="width:80px;">
                        </div>
                    </div>
                </div>
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Connection Status:</span>
                        <div class="control">
                            <span id="moonraker_status" style="color:#888;">Not connected</span>
                        </div>
                    </div>
                </div>
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Camera IP:</span>
                        <div class="control">
                            <select id="mr-settings-camera-ip" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                <option value="auto">Auto</option>
                                <option value="localhost">Localhost (127.0.0.1)</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-note">IP used in Moonraker camera URLs. Auto = localhost when Moonraker is local, otherwise printer's IP.</div>
                </div>
            </div>
            <hr style="border-color:#444;margin:15px 0;">
            <div id="moonraker-cameras-list">
                <!-- Populated by JavaScript -->
                <div style="color:#888;font-size:12px;">Loading cameras...</div>
            </div>
            <div style="margin-top:15px;">
                <button type="button" onclick="applyMoonrakerSettings()">Apply Moonraker Settings</button>
                <span id="moonraker-status" style="margin-left:10px;font-size:12px;"></span>
            </div>
        </div>

        <div class="section" id="fd-status-section">
            <h2>FAULT DETECTION</h2>
            <div class="row">
                <span class="label">Status:</span>
                <span class="value" id="fd-status" style="font-weight:bold;">-</span>
            </div>
            <div class="row">
                <span class="label">Detection:</span>
                <span class="value" id="fd-detection">-</span>
            </div>
            <div class="row" id="fd-class-row" style="display:none">
                <span class="label">Fault Type:</span>
                <span class="value" id="fd-class">-</span>
            </div>
            <div class="row" id="fd-confidence-row" style="display:none">
                <span class="label">Confidence:</span>
                <span class="value" id="fd-confidence">-</span>
            </div>
            <div class="row" id="fd-models-row" style="display:none">
                <span class="label">Models:</span>
                <span class="value" id="fd-models" style="font-size:11px;font-family:monospace;white-space:pre;line-height:1.6;">-</span>
            </div>
            <div class="row" id="fd-timing-row" style="display:none">
                <span class="label">Inference:</span>
                <span class="value" id="fd-timing">-</span>
            </div>
            <div class="row" id="fd-heatmap-row" style="display:none">
                <span class="label">Heatmap:</span>
                <div class="value" style="display:flex;flex-direction:column;gap:4px;align-items:flex-end;">
                    <span id="fd-heatmap-info" style="font-size:11px;color:#ccc;"></span>
                    <div id="fd-heatmap-container" style="position:relative;display:inline-block;max-width:50%;">
                        <img id="fd-frame-img" style="display:block;max-width:100%;border-radius:4px;border:1px solid #555;" />
                        <canvas id="fd-heatmap-canvas" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;border-radius:4px;"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="fd-config-section">
            <h2>FAULT DETECTION SETTINGS</h2>
            <p style="color:#888;font-size:12px;margin-bottom:15px;" id="fd-npu-warning" hidden>
                NPU not available on this printer
            </p>
            <div style="padding: 0 12%;">
                <div class="setting">
                    <div class="setting-row">
                        <span class="label">Enable:</span>
                        <div class="control">
                            <label class="toggle">
                                <input type="checkbox" id="fd_enabled" $fd_enabled_checked onchange="updateFdVisibility()">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <div id="fd-details">
                    <div class="setting">
                        <div class="setting-row">
                            <span class="label">Model Set:</span>
                            <div class="control">
                                <select id="fd_model_set" onchange="onFdSetChange()" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;max-width:200px;">
                                    <option value="">Loading...</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="setting" id="fd-models-container" style="display:none;">
                        <div class="setting-row">
                            <span class="label">Models:</span>
                            <div class="control" style="flex-direction:column;align-items:flex-end;">
                                <div id="fd-models-list" style="font-size:12px;color:#ccc;"></div>
                            </div>
                        </div>
                    </div>

                    <div class="setting">
                        <div class="setting-row">
                            <span class="label">Strategy:</span>
                            <div class="control">
                                <select id="fd_strategy" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                    <option value="and">AND (CNN+Proto)</option>
                                    <option value="or">OR (any model)</option>
                                    <option value="majority">Majority</option>
                                    <option value="all">All Agree</option>
                                    <option value="verify">Verify</option>
                                    <option value="classify">Classify OR</option>
                                    <option value="classify_and">Classify AND</option>
                                    <option value="cnn">CNN Only</option>
                                    <option value="protonet">ProtoNet Only</option>
                                    <option value="multiclass">Multiclass Only</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="setting">
                        <div class="setting-row">
                            <span class="label">Fault Heatmap:</span>
                            <div class="control">
                                <label class="toggle">
                                    <input type="checkbox" id="fd_heatmap" $heatmap_checked>
                                    <span class="slider"></span>
                                </label>
                                <span style="font-size:11px;color:#888;margin-left:8px;">Spatial localization on faults</span>
                            </div>
                        </div>
                    </div>

                    <div class="setting">
                        <div class="setting-row">
                            <span class="label">Fault Alert:</span>
                            <div class="control">
                                <select id="fd_beep_pattern" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;">
                                    <option value="0">None</option>
                                    <option value="1">Short beep</option>
                                    <option value="2">2 short beeps</option>
                                    <option value="3">3 short beeps</option>
                                    <option value="4">2 short + 1 long</option>
                                    <option value="5">SOS</option>
                                </select>
                                <span style="font-size:11px;color:#888;margin-left:8px;">Buzzer pattern on fault (15s cooldown)</span>
                            </div>
                        </div>
                    </div>

                    <div class="setting">
                        <div class="setting-row">
                            <span class="label">Spatial Calibration:</span>
                            <div class="control" style="display:flex;align-items:center;gap:10px;">
                                <span id="fd-setup-badge" style="font-size:12px;padding:3px 8px;border-radius:3px;"></span>
                                <button type="button" onclick="window.open('/setup','fd_setup','width=960,height=750')"
                                        class="secondary" style="padding:6px 14px;font-size:13px;">Setup</button>
                            </div>
                        </div>
                        <span id="fd-setup-last" class="setting-note"></span>
                    </div>

                    <div class="setting">
                        <div class="setting-row">
                            <span class="label">Check interval:</span>
                            <div class="control">
                                <input type="number" id="fd_interval" min="1" max="60" value="5" style="width:50px;"> <span style="color:#888">sec</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting">
                        <div class="setting-row">
                            <span class="label">Verify interval:</span>
                            <div class="control">
                                <input type="number" id="fd_verify_interval" min="1" max="30" value="2" style="width:50px;"> <span style="color:#888">sec</span>
                            </div>
                        </div>
                    </div>

                    <div class="setting" id="fd-threshold-section" style="display:none;margin-top:10px;">
                        <div class="setting-row">
                            <span class="label">Profile:</span>
                            <div class="control" style="gap:8px;">
                                <select id="fd_profile" onchange="onFdProfileChange()" style="padding:8px;border-radius:4px;border:1px solid #555;background:#333;color:#fff;min-width:200px;">
                                </select>
                                <label style="font-size:12px;color:#ccc;white-space:nowrap;">
                                    <input type="checkbox" id="fd_custom" onchange="onFdCustomToggle()"> Custom
                                </label>
                            </div>
                        </div>
                        <div id="fd-threshold-inputs" style="margin-top:8px;">
                            <div id="fd-th-cnn-row">
                                <div class="setting-row">
                                    <span class="label" style="font-size:12px;">CNN threshold:</span>
                                    <div class="control" style="gap:4px;">
                                        <input type="number" id="fd_th_cnn" min="0.01" max="0.99" step="0.01" style="width:60px;" disabled>
                                        <span style="color:#888;font-size:11px;">Dynamic:</span>
                                        <input type="number" id="fd_th_cnn_dyn" min="0.01" max="0.99" step="0.01" style="width:60px;" disabled>
                                    </div>
                                </div>
                                <div style="font-size:10px;color:#777;padding:1px 0 4px 20px;line-height:1.4;">
                                    CNN confidence required to flag a fault. Higher = fewer false alarms, lower = more sensitive.<br>
                                    <em>Dynamic</em>: reduced threshold used when ProtoNet also detects a fault (see trigger below).
                                </div>
                            </div>
                            <div id="fd-th-proto-row">
                                <div class="setting-row">
                                    <span class="label" style="font-size:12px;">Proto threshold:</span>
                                    <div class="control" style="gap:4px;">
                                        <input type="number" id="fd_th_proto" min="0.01" max="0.99" step="0.01" style="width:60px;" disabled>
                                        <span style="color:#888;font-size:11px;">Trigger:</span>
                                        <input type="number" id="fd_th_proto_trig" min="0.01" max="0.99" step="0.01" style="width:60px;" disabled>
                                    </div>
                                </div>
                                <div style="font-size:10px;color:#777;padding:1px 0 4px 20px;line-height:1.4;">
                                    ProtoNet similarity margin required to flag a fault. Higher = more conservative.<br>
                                    <em>Trigger</em>: when ProtoNet margin exceeds this, CNN switches to its lower dynamic threshold.
                                </div>
                            </div>
                            <div id="fd-th-multi-row">
                                <div class="setting-row">
                                    <span class="label" style="font-size:12px;">Multi threshold:</span>
                                    <div class="control">
                                        <input type="number" id="fd_th_multi" min="0.01" max="0.99" step="0.01" style="width:60px;" disabled>
                                    </div>
                                </div>
                                <div style="font-size:10px;color:#777;padding:1px 0 4px 20px;line-height:1.4;">
                                    Multiclass confidence for fault type classification. Higher = fewer false positives.<br>
                                    In Verify/Classify strategies, a low internal threshold (0.10) is used for type labeling only.
                                </div>
                            </div>
                            <div id="fd-th-heatmap-row">
                                <div class="setting-row">
                                    <span class="label" style="font-size:12px;">Heatmap boost:</span>
                                    <div class="control">
                                        <input type="number" id="fd_th_heatmap" min="0.5" max="3.0" step="0.05" style="width:60px;" disabled>
                                    </div>
                                </div>
                                <div style="font-size:10px;color:#777;padding:1px 0 4px 20px;line-height:1.4;">
                                    Minimum spatial heatmap score for heatmap-only boost override (Path 1).<br>
                                    Higher = fewer false positives, lower = catches smaller defects. Range 0.5-3.0.
                                </div>
                            </div>
                            <details id="fd-advanced-boost" style="margin-top:8px;">
                                <summary style="cursor:pointer;font-size:12px;color:#aaa;">Advanced Boost Settings</summary>
                                <div style="margin-top:6px;">
                                    <div style="font-size:10px;color:#888;padding:0 0 6px 8px;">Boost activation</div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Min strong cells:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_min_cells" min="1" max="50" step="1" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Cell threshold:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_cell_th" min="0.05" max="2.0" step="0.05" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div style="font-size:10px;color:#888;padding:4px 0 6px 8px;">Corroboration gates</div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Lean factor:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_lean" min="0.1" max="1.0" step="0.05" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Proto lean:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_proto_lean" min="0.1" max="0.99" step="0.01" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Multi lean:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_multi_lean" min="0.05" max="0.99" step="0.01" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Proto veto:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_proto_veto" min="0.1" max="0.99" step="0.01" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Proto strong:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_proto_strong" min="0.5" max="0.99" step="0.01" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div style="font-size:10px;color:#888;padding:4px 0 6px 8px;">Confidence &amp; smoothing</div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Amplifier cap:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_amp_cap" min="1.0" max="5.0" step="0.1" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Confidence cap:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_boost_conf_cap" min="0.5" max="1.0" step="0.01" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">EMA alpha:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_ema_alpha" min="0.05" max="1.0" step="0.05" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <span class="label" style="font-size:11px;">Coarse weight:</span>
                                        <div class="control">
                                            <input type="number" id="fd_th_coarse_wt" min="0.0" max="1.0" step="0.05" style="width:60px;" disabled>
                                        </div>
                                    </div>
                                </div>
                            </details>
                        </div>
                    </div>

                    <div class="setting" style="margin-top:15px;">
                        <button type="button" onclick="applyFdSettings()">Apply</button>
                        <span id="fd-status-msg" style="margin-left:10px;font-size:12px;"></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="proto-section">
            <h2>Prototype Management</h2>
            <div style="display:flex;gap:20px;flex-wrap:wrap;">
                <!-- Datasets panel -->
                <div style="flex:1;min-width:280px;">
                    <h3 style="margin:0 0 8px 0;font-size:14px;">Datasets</h3>
                    <div id="proto-datasets-list" style="margin-bottom:8px;font-size:13px;"></div>
                    <div style="display:flex;gap:5px;flex-wrap:wrap;">
                        <button type="button" onclick="protoDownloadDataset()" id="proto-dl-btn" style="font-size:12px;">Download Default</button>
                        <button type="button" onclick="protoCreateDataset()" style="font-size:12px;">New Dataset</button>
                    </div>
                    <div id="proto-dl-status" style="display:none;margin-top:6px;font-size:12px;">
                        <div style="background:#333;border-radius:3px;height:16px;overflow:hidden;margin-bottom:3px;">
                            <div id="proto-dl-bar" style="background:#4a9eff;height:100%;width:0%;transition:width 0.3s;"></div>
                        </div>
                        <span id="proto-dl-text"></span>
                    </div>
                </div>

                <!-- Prototype Sets panel -->
                <div style="flex:1;min-width:280px;">
                    <h3 style="margin:0 0 8px 0;font-size:14px;">Prototype Sets</h3>
                    <div id="proto-sets-list" style="margin-bottom:8px;font-size:13px;"></div>
                </div>
            </div>

            <!-- Compute Controls -->
            <div style="margin-top:12px;padding-top:10px;border-top:1px solid #444;">
                <h3 style="margin:0 0 8px 0;font-size:14px;">Compute Prototypes</h3>
                <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                    <label style="font-size:12px;">Dataset:</label>
                    <select id="proto-compute-dataset" style="font-size:12px;"></select>
                    <label style="font-size:12px;">Set name:</label>
                    <input type="text" id="proto-compute-setname" style="font-size:12px;width:100px;" placeholder="e.g. default">
                    <button type="button" onclick="protoStartCompute(false)" style="font-size:12px;">Compute</button>
                    <button type="button" onclick="protoStartCompute(true)" style="font-size:12px;">Incremental</button>
                    <button type="button" onclick="protoCancelCompute()" id="proto-cancel-btn" style="font-size:12px;display:none;">Cancel</button>
                </div>
                <div id="proto-compute-status" style="display:none;margin-top:8px;">
                    <div style="background:#333;border-radius:3px;height:18px;overflow:hidden;margin-bottom:4px;">
                        <div id="proto-compute-bar" style="background:#4a9eff;height:100%;width:0%;transition:width 0.3s;"></div>
                    </div>
                    <span id="proto-compute-text" style="font-size:12px;"></span>
                </div>
                <div id="proto-compute-results" style="display:none;margin-top:8px;font-size:13px;"></div>
            </div>

            <!-- Capture to Dataset -->
            <div style="margin-top:12px;padding-top:10px;border-top:1px solid #444;">
                <h3 style="margin:0 0 8px 0;font-size:14px;">Capture to Dataset</h3>
                <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                    <select id="proto-capture-dataset" style="font-size:12px;"></select>
                    <button type="button" onclick="protoSaveFrame('failure')" style="font-size:12px;background:#a33;">Save as Failure</button>
                    <button type="button" onclick="protoSaveFrame('success')" style="font-size:12px;">Save as Success</button>
                    <span id="proto-capture-msg" style="font-size:12px;"></span>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Status</h2>
            <div class="row">
                <span class="label">Encoder:</span>
                <span class="value" id="status-encoder">$encoder_type</span>
            </div>
            <div id="status-ports"></div>
        </div>
    </div>

    <script>
        let flvPlayer = null;
        let flvPlayerBusy = false;
        let mjpegActive = false;
        let statsInterval = null;
        let currentEncoderType = '$encoder_type';
        let currentH264Resolution = '$h264_resolution';
        let currentSessionId = '$session_id';

        // Streaming server base URL
        const streamingPort = $streaming_port;
        const controlPort = $control_port;
        const streamBase = (streamingPort == location.port || !streamingPort) ? '' : 'http://' + location.hostname + ':' + streamingPort;

        // FLV port is always 18088
        const FLV_PORT = 18088;

        // Dynamic URL variables that update when switching cameras
        let snapshotUrl = streamBase + '/snapshot';
        let mjpegUrl = streamBase + '/stream';
        let flvUrl = 'http://' + location.hostname + ':' + FLV_PORT + '/flv';
        let displayUrl = streamBase + '/display';

        // Status message helper
        function showStatus(msg, type) {
            console.log('[Status] ' + msg);
        }

        // Initialize stream URLs on page load
        function initStreamUrls() {
            if (!streamBase) {
                // Same port, use relative URLs
                snapshotUrl = '/snapshot';
                mjpegUrl = '/stream';
                displayUrl = '/display';
            }

            // Update preview image
            const previewImg = document.getElementById('preview-img');
            if (previewImg) {
                previewImg.src = snapshotUrl;
                previewImg.onclick = function() { this.src = snapshotUrl + '?' + Date.now(); };
            }

            // Update links
            document.querySelectorAll('a[href="/stream"]').forEach(a => {
                a.href = mjpegUrl;
            });
            document.querySelectorAll('a[href="/snapshot"]').forEach(a => {
                a.href = snapshotUrl;
            });
            document.querySelectorAll('a[href="/display"]').forEach(a => {
                a.href = displayUrl;
            });
        }
        document.addEventListener('DOMContentLoaded', initStreamUrls);

        // Camera selector
        let cameras = [];
        let activeCameraId = 1;

        function loadCameras() {
            fetch('/api/cameras')
                .then(r => r.json())
                .then(data => {
                    cameras = data.cameras || [];
                    // If active camera is no longer running/enabled, switch to primary
                    if (activeCameraId !== 1) {
                        const activeCam = cameras.find(c => c.id === activeCameraId);
                        if (!activeCam || !activeCam.enabled || !activeCam.running || activeCam.error) {
                            switchCamera(1);
                        }
                    }
                    renderCameraSelector();
                    updateStatusPorts();
                })
                .catch(err => console.log('Camera load error:', err));
        }

        function renderCameraSelector() {
            const container = document.getElementById('camera-selector');
            if (!container) return;

            // Only show if more than one camera
            if (cameras.length <= 1) {
                container.style.display = 'none';
                updateCameraStatusPanel();
                return;
            }

            container.style.display = 'flex';
            container.innerHTML = cameras.map(cam => {
                const isActive = cam.id === activeCameraId;
                const isEnabled = cam.enabled;
                const isPrimary = cam.is_primary;
                const hasError = cam.error != null;
                const camRes = cam.configured_resolution || (cam.width + 'x' + cam.height);
                const camMode = cam.capture_mode || (cam.has_mjpeg ? 'mjpeg' : 'yuyv');
                const title = `${cam.name} (${camRes} ${camMode}, port ${cam.streaming_port})${isEnabled ? '' : ' - disabled'}${hasError ? ' - ERROR' : ''}`;

                // Primary camera button (cannot be disabled)
                if (isPrimary) {
                    return `<button class="${isActive ? 'active' : ''}" onclick="switchCamera(${cam.id})" title="${title}">CAM#${cam.id}</button>`;
                }

                // Secondary cameras: show with enable/disable toggle and error indicator
                const toggleClass = isEnabled ? 'enabled' : '';
                const toggleTitle = isEnabled ? 'Click to disable' : 'Click to enable';
                const toggleText = isEnabled ? 'ON' : 'OFF';
                const errorIndicator = hasError ? '<span style="color:#f44;margin-left:2px;">!</span>' : '';
                return `<button class="${isActive ? 'active' : ''}" ${isEnabled && !hasError ? '' : 'disabled'} onclick="switchCamera(${cam.id})" title="${title}">CAM#${cam.id}${errorIndicator}</button><span class="cam-enable-toggle ${toggleClass}" title="${toggleTitle}" onclick="toggleCameraEnabled(${cam.id}, ${!isEnabled})">${toggleText}</span>`;
            }).join('');

            updateCameraStatusPanel();
        }

        function updateStatusPorts() {
            const panel = document.getElementById('status-ports');
            if (!panel) return;
            const host = location.hostname;
            const sp = streamingPort;
            const cp = controlPort;
            const h264cb = document.querySelector('[name=h264_enabled]');
            const h264on = h264cb && h264cb.checked;
            const proxycb = document.querySelector('[name=acproxycam_flv_proxy]');
            const proxyon = proxycb && proxycb.checked;
            const dispcb = document.querySelector('[name=display_enabled]');
            const dispon = dispcb && dispcb.checked;
            const hasFlv = h264on || proxyon;
            const lnk = (port, path) => '<a href="http://' + host + ':' + port + path + '" target="_blank" style="color:#888;">' + path + '</a>';
            let html = '';

            // Primary streaming port + endpoints
            html += '<div class="row rkmpi-only"><span class="label">Streaming Port (CAM#1):</span>';
            html += '<span class="value">' + sp + '</span></div>';
            html += '<div class="row rkmpi-only" style="margin-top:-4px;"><span class="label"></span>';
            html += '<span class="value" style="font-size:11px;color:#888;">';
            html += lnk(sp, '/stream') + ' ' + lnk(sp, '/snapshot');
            if (dispon) html += ' ' + lnk(sp, '/display') + ' ' + lnk(sp, '/display/snapshot');
            html += '</span></div>';

            // Secondary camera ports
            const secondary = cameras.filter(c => !c.is_primary && c.enabled && c.running);
            secondary.forEach(cam => {
                const p = cam.streaming_port;
                html += '<div class="row rkmpi-only"><span class="label">Streaming Port (CAM#' + cam.id + '):</span>';
                html += '<span class="value">' + p + '</span></div>';
                html += '<div class="row rkmpi-only" style="margin-top:-4px;"><span class="label"></span>';
                html += '<span class="value" style="font-size:11px;color:#888;">';
                html += lnk(p, '/stream') + ' ' + lnk(p, '/snapshot');
                html += '</span></div>';
            });

            // FLV port (H.264 encoder or ACProxyCam proxy)
            if (hasFlv) {
                html += '<div class="row rkmpi-only"><span class="label">FLV Port:</span>';
                html += '<span class="value">' + FLV_PORT + '</span></div>';
                html += '<div class="row rkmpi-only" style="margin-top:-4px;"><span class="label"></span>';
                html += '<span class="value" style="font-size:11px;color:#888;">';
                html += lnk(FLV_PORT, '/flv');
                html += '</span></div>';
            }

            // Control port + endpoints
            html += '<div class="row rkmpi-only"><span class="label">Control Port:</span>';
            html += '<span class="value">' + cp + '</span></div>';
            html += '<div class="row rkmpi-only" style="margin-top:-4px;"><span class="label"></span>';
            html += '<span class="value" style="font-size:11px;color:#888;">';
            html += lnk(cp, '/control') + ' ' + lnk(cp, '/timelapse') + ' ' + lnk(cp, '/status') + ' ' + lnk(cp, '/api/stats') + ' ' + lnk(cp, '/api/cameras');
            html += '</span></div>';

            panel.innerHTML = html;
        }

        function updateCameraStatusPanel() {
            const panel = document.getElementById('camera-status-panel');
            if (!panel) return;

            // Show status for non-primary cameras
            const secondaryCams = cameras.filter(c => !c.is_primary);
            if (secondaryCams.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            let html = '<div style="font-size:12px;color:#888;margin-bottom:8px;">Additional Cameras Settings:</div>';
            secondaryCams.forEach(cam => {
                const statusColor = cam.error ? '#f44' : (cam.running ? '#4CAF50' : '#888');
                const statusText = cam.error ? 'Error' : (cam.running ? 'Running' : (cam.enabled ? 'Starting...' : 'Disabled'));
                const enabledChecked = cam.enabled ? 'checked' : '';
                const res = cam.configured_resolution || (cam.width + 'x' + cam.height);
                const fps = cam.mjpeg_fps || 10;

                html += `<div style="background:#222;padding:8px;margin-bottom:8px;border-radius:4px;">`;
                html += `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">`;
                html += `<span><strong>CAM#${cam.id}</strong>: ${cam.name.substring(0,25)}</span>`;
                html += `<span style="color:${statusColor};">&bull; ${statusText}</span>`;
                html += `</div>`;

                if (cam.error) {
                    html += `<div style="color:#f44;font-size:11px;background:#411;padding:4px 6px;border-radius:3px;margin-bottom:6px;">${cam.error}</div>`;
                }

                // Settings row
                html += `<div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;font-size:11px;">`;
                // Enable toggle
                html += `<label style="display:flex;align-items:center;gap:4px;cursor:pointer;">`;
                html += `<input type="checkbox" ${enabledChecked} onchange="toggleCameraEnabled(${cam.id}, this.checked)"> Enable`;
                html += `</label>`;
                // Resolution (dynamically populated from camera capabilities)
                html += `<label style="display:flex;align-items:center;gap:4px;">Res:`;
                html += `<select id="cam${cam.id}-res" style="font-size:11px;padding:2px;" ${cam.enabled ? '' : 'disabled'}>`;
                const supportedRes = cam.supported_resolutions || ['640x480'];
                supportedRes.forEach(r => {
                    html += `<option value="${r}" ${res === r ? 'selected' : ''}>${r}</option>`;
                });
                html += `</select></label>`;
                // FPS
                html += `<label style="display:flex;align-items:center;gap:4px;">FPS:`;
                html += `<input type="number" id="cam${cam.id}-fps" value="${fps}" min="1" max="15" style="width:40px;font-size:11px;padding:2px;" ${cam.enabled ? '' : 'disabled'}>`;
                html += `</label>`;
                // Apply button (highlighted)
                html += `<button onclick="applySecondaryCamera(${cam.id})" style="font-size:11px;padding:2px 8px;background:#2563eb;color:white;border:none;border-radius:3px;cursor:pointer;" ${cam.enabled ? '' : 'disabled'}>Apply</button>`;
                html += `</div>`;
                html += `</div>`;
            });
            panel.innerHTML = html;
        }

        function applySecondaryCamera(camId) {
            const res = document.getElementById(`cam${camId}-res`).value;
            const fps = parseInt(document.getElementById(`cam${camId}-fps`).value) || 10;
            showStatus(`Applying ${res} @ ${fps}fps to CAM#${camId}...`);
            fetch('/api/camera/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: 'id=' + camId + '&resolution=' + encodeURIComponent(res) + '&mjpeg_fps=' + fps
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'ok') {
                    showStatus(`CAM#${camId}: Restarting at ${res}...`);
                    // Wait longer for encoder to start and potentially report errors
                    setTimeout(() => {
                        loadCameras();
                        showStatus(`CAM#${camId}: Settings applied (${res} @ ${fps}fps)`);
                    }, 3500);
                } else {
                    showStatus('Error: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(e => showStatus('Error: ' + e, 'error'));
        }

        function switchCamera(id) {
            const cam = cameras.find(c => c.id === id);
            if (!cam || !cam.enabled) return;
            if (id === activeCameraId) return;

            // Update UI immediately
            activeCameraId = id;
            renderCameraSelector();

            // Update stream URLs to point to this camera's port
            const host = location.hostname;
            const port = cam.streaming_port;
            const baseUrl = `http://${host}:${port}`;

            // Update preview sources
            snapshotUrl = `${baseUrl}/snapshot`;
            mjpegUrl = `${baseUrl}/stream`;

            // FLV only available for primary camera
            const flvTab = document.querySelector('.tabs button:nth-child(3)');
            if (cam.is_primary) {
                flvUrl = `http://${host}:${FLV_PORT}/flv`;
                if (flvTab) {
                    flvTab.disabled = false;
                    flvTab.style.opacity = '1';
                    flvTab.title = 'H.264 FLV stream';
                }
            } else {
                flvUrl = null;
                if (flvTab) {
                    flvTab.disabled = true;
                    flvTab.style.opacity = '0.5';
                    flvTab.title = 'H.264 FLV only available for primary camera';
                }
                // If FLV tab is active, switch to snapshot
                if (currentTab === 'flv') {
                    switchTab('snapshot');
                }
            }

            // Refresh preview with new camera
            refreshPreview();

            // Reload camera controls if panel is expanded
            if (cameraControlsExpanded) {
                loadCameraControls();
            } else {
                cameraControlsLoaded = false;
            }
        }

        function toggleCameraEnabled(id, enabled) {
            const endpoint = enabled ? '/api/camera/enable' : '/api/camera/disable';

            fetch(endpoint, {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: 'id=' + id
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'ok') {
                    // If disabling the currently active camera, switch to primary
                    if (!enabled && id === activeCameraId) {
                        switchCamera(1);
                    }
                    // Reload camera list to get updated state
                    loadCameras();
                } else {
                    alert('Camera toggle failed: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(err => alert('Camera toggle error: ' + err));
        }

        // Moonraker Camera Settings
        let moonrakerCameraSettings = {};

        function loadMoonrakerCameraSettings() {
            fetch('/api/moonraker/cameras')
                .then(r => r.json())
                .then(data => {
                    moonrakerCameraSettings = data.settings || {};
                    renderMoonrakerCamerasList(data.cameras || []);
                })
                .catch(err => console.log('Moonraker settings load error:', err));
        }

        function renderMoonrakerCamerasList(cameraList) {
            const container = document.getElementById('moonraker-cameras-list');
            if (!container) return;

            if (cameraList.length === 0) {
                container.innerHTML = '<div style="color:#888;font-size:12px;">No cameras detected.</div>';
                return;
            }

            let html = '<table style="width:100%;border-collapse:collapse;font-size:12px;">';
            html += '<tr style="border-bottom:1px solid #444;"><th style="text-align:left;padding:5px;">Camera</th><th style="text-align:left;padding:5px;">Name in Moonraker</th><th style="text-align:center;padding:5px;">Provision</th><th style="text-align:center;padding:5px;">Default</th></tr>';

            cameraList.forEach(cam => {
                const uniqueId = cam.unique_id || `camera_${cam.id}`;
                const settings = moonrakerCameraSettings[uniqueId] || {};
                const moonrakerName = settings.moonraker_name || `USB Camera ${cam.id === 1 ? '' : cam.id}`.trim();
                const moonrakerEnabled = settings.moonraker_enabled !== false;  // Default true
                const isDefault = settings.moonraker_default === true;
                const portInfo = cam.streaming_port ? ` (port ${cam.streaming_port})` : '';

                html += `<tr style="border-bottom:1px solid #333;">`;
                html += `<td style="padding:8px 5px;"><strong>CAM#${cam.id}</strong><br><span style="color:#888;font-size:11px;">${cam.name}${portInfo}</span></td>`;
                html += `<td style="padding:8px 5px;"><input type="text" id="mr-name-${cam.id}" value="${moonrakerName}" data-unique-id="${uniqueId}" style="width:150px;padding:4px;background:#222;border:1px solid #444;color:#fff;border-radius:3px;"></td>`;
                html += `<td style="padding:8px 5px;text-align:center;"><input type="checkbox" id="mr-enabled-${cam.id}" ${moonrakerEnabled ? 'checked' : ''} data-unique-id="${uniqueId}" style="width:18px;height:18px;cursor:pointer;"></td>`;
                html += `<td style="padding:8px 5px;text-align:center;"><input type="radio" name="mr-default" id="mr-default-${cam.id}" value="${cam.id}" ${isDefault ? 'checked' : ''} data-unique-id="${uniqueId}" style="width:18px;height:18px;cursor:pointer;"></td>`;
                html += `</tr>`;
            });

            html += '</table>';
            container.innerHTML = html;
        }

        function applyMoonrakerSettings() {
            const statusEl = document.getElementById('moonraker-status');
            statusEl.textContent = 'Applying...';
            statusEl.style.color = '#888';

            // Gather connection settings
            const hostEl = document.getElementById('mr-settings-host');
            const portEl = document.getElementById('mr-settings-port');
            const camIpEl = document.getElementById('mr-settings-camera-ip');

            // Gather camera settings from form
            const settings = {};
            let defaultCamId = null;

            document.querySelectorAll('#moonraker-cameras-list input[type="text"]').forEach(input => {
                const camId = input.id.replace('mr-name-', '');
                const uniqueId = input.dataset.uniqueId;
                if (!settings[uniqueId]) settings[uniqueId] = {};
                settings[uniqueId].moonraker_name = input.value.trim() || `USB Camera ${camId}`;
            });

            document.querySelectorAll('#moonraker-cameras-list input[type="checkbox"]').forEach(input => {
                const uniqueId = input.dataset.uniqueId;
                if (!settings[uniqueId]) settings[uniqueId] = {};
                settings[uniqueId].moonraker_enabled = input.checked;
            });

            document.querySelectorAll('#moonraker-cameras-list input[type="radio"]').forEach(input => {
                const uniqueId = input.dataset.uniqueId;
                if (!settings[uniqueId]) settings[uniqueId] = {};
                settings[uniqueId].moonraker_default = input.checked;
                if (input.checked) defaultCamId = input.value;
            });

            const payload = {
                settings: settings,
                moonraker_host: hostEl ? hostEl.value.trim() || '127.0.0.1' : '127.0.0.1',
                moonraker_port: portEl ? portEl.value || '7125' : '7125',
                moonraker_camera_ip: camIpEl ? camIpEl.value : 'auto'
            };

            fetch('/api/moonraker/cameras', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'ok') {
                    statusEl.textContent = 'Settings applied!';
                    statusEl.style.color = '#4CAF50';
                    moonrakerCameraSettings = settings;
                    setTimeout(() => { statusEl.textContent = ''; checkMoonrakerStatus(); }, 2000);
                } else {
                    statusEl.textContent = 'Error: ' + (data.error || 'Unknown error');
                    statusEl.style.color = '#f44';
                }
            })
            .catch(err => {
                statusEl.textContent = 'Error: ' + err;
                statusEl.style.color = '#f44';
            });
        }

        // Load network interfaces for Camera IP select
        function loadNetworkInterfaces() {
            fetch('/api/network/interfaces')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('mr-settings-camera-ip');
                    if (!select) return;
                    const currentVal = data.moonraker_camera_ip || 'auto';
                    // Clear dynamic options (keep Auto and Localhost)
                    while (select.options.length > 2) select.remove(2);
                    // Add interface options
                    if (data.eth0) {
                        const opt = document.createElement('option');
                        opt.value = 'eth0';
                        opt.textContent = 'eth0 (' + data.eth0 + ')';
                        select.appendChild(opt);
                    }
                    if (data.eth1) {
                        const opt = document.createElement('option');
                        opt.value = 'eth1';
                        opt.textContent = 'eth1 (' + data.eth1 + ')';
                        select.appendChild(opt);
                    }
                    select.value = currentVal;
                })
                .catch(err => console.log('Network interfaces load error:', err));
        }

        // Load moonraker settings when cameras are loaded
        function loadCamerasAndMoonraker() {
            updateStatusPorts();
            loadCameras();
            loadMoonrakerCameraSettings();
            loadNetworkInterfaces();
            checkMoonrakerStatus();
            setInterval(checkMoonrakerStatus, 10000);  /* Poll every 10s for encode status */
        }

        function refreshPreview() {
            const previewImg = document.getElementById('preview-img');
            if (previewImg && currentTab === 'snapshot') {
                previewImg.src = snapshotUrl + '?' + Date.now();
            } else if (currentTab === 'mjpeg') {
                const mjpegImg = document.getElementById('mjpeg-stream');
                if (mjpegImg) mjpegImg.src = mjpegUrl + '?' + Date.now();
            }
        }

        document.addEventListener('DOMContentLoaded', loadCamerasAndMoonraker);

        // Clean up all streams on page unload (prevents stale server connections)
        window.addEventListener('pagehide', function() {
            stopMjpegStream();
            stopDisplayStream();
            stopFlvPlayer();
        });

        // Poll camera status every 5s to detect async errors/crashes
        setInterval(function() {
            if (cameras.length > 1) loadCameras();
        }, 5000);

        // Show/hide settings based on encoder type
        function updateEncoderVisibility() {
            const encoderType = document.getElementById('encoder_type').value;
            const isRkmpi = encoderType === 'rkmpi' || encoderType === 'rkmpi-yuyv';
            document.querySelectorAll('.rkmpi-only').forEach(el => {
                el.style.display = isRkmpi ? '' : 'none';
            });
            // rkmpi-mjpeg-only: skip-rate controls only for rkmpi (MJPEG mode)
            document.querySelectorAll('.rkmpi-mjpeg-only').forEach(el => {
                el.style.display = encoderType === 'rkmpi' ? '' : 'none';
            });
            // rkmpi-yuyv-only: settings specific to YUYV mode
            document.querySelectorAll('.rkmpi-yuyv-only').forEach(el => {
                el.style.display = encoderType === 'rkmpi-yuyv' ? '' : 'none';
            });
            // Camera resolution notes - show appropriate note for encoder type
            document.querySelectorAll('.rkmpi-mjpeg-note').forEach(el => {
                el.style.display = encoderType === 'rkmpi' ? '' : 'none';
            });
            document.querySelectorAll('.rkmpi-yuyv-note').forEach(el => {
                el.style.display = encoderType === 'rkmpi-yuyv' ? '' : 'none';
            });
        }

        // Handle encoder type change - requires restart
        function handleEncoderChange(select) {
            const newType = select.value;
            if (newType === currentEncoderType) {
                updateEncoderVisibility();
                return;
            }

            // Confirm with user
            if (!confirm('Changing encoder type requires a restart.\nThe page will reload automatically when ready.\n\nContinue?')) {
                select.value = currentEncoderType;
                return;
            }

            // Show loading overlay
            const overlay = document.getElementById('loading-overlay');
            const statusEl = document.getElementById('loading-status');
            overlay.classList.add('active');
            statusEl.textContent = 'Saving settings...';

            // Save all current form settings with the new encoder type
            const formData = new FormData(document.getElementById('settings-form'));
            const data = new URLSearchParams();
            data.append('encoder_type', newType);
            data.append('autolanmode', formData.has('autolanmode') ? '1' : '0');
            data.append('logging', formData.has('logging') ? '1' : '0');
            data.append('log_max_size', document.querySelector('[name=log_max_size]').value);
            data.append('h264_enabled', formData.has('h264_enabled') ? '1' : '0');
            data.append('skip_ratio', document.querySelector('[name=skip_ratio]').value);
            data.append('auto_skip', formData.has('auto_skip') ? '1' : '0');
            data.append('target_cpu', document.querySelector('[name=target_cpu]').value);
            data.append('bitrate', document.querySelector('[name=bitrate]').value);
            data.append('mjpeg_fps', document.querySelector('[name=mjpeg_fps]').value);
            data.append('h264_resolution', document.querySelector('[name=h264_resolution]')?.value || '1280x720');
            // Display capture settings
            data.append('display_enabled', formData.has('display_enabled') ? 'on' : '');
            data.append('display_fps', document.querySelector('[name=display_fps]').value);
            // ACProxyCam FLV proxy
            if (formData.has('acproxycam_flv_proxy')) {
                data.append('acproxycam_flv_proxy', '1');
            }

            // Save settings, then restart
            // Stop stats polling during restart to avoid connection errors
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }

            fetch('/control', {
                method: 'POST',
                body: data
            }).then(() => {
                statusEl.textContent = 'Requesting restart...';
                return fetch('/api/restart');
            }).then(() => {
                statusEl.textContent = 'Waiting for server to restart...';
                // Poll until server is back
                pollForRestart();
            }).catch(err => {
                statusEl.textContent = 'Error: ' + err.message;
                setTimeout(() => {
                    overlay.classList.remove('active');
                    select.value = currentEncoderType;
                }, 3000);
            });
        }

        // Poll server until it comes back online with a NEW session ID
        function pollForRestart() {
            const statusEl = document.getElementById('loading-status');
            const oldSessionId = currentSessionId;
            let attempts = 0;
            const maxAttempts = 45;

            const poll = () => {
                attempts++;
                statusEl.textContent = 'Waiting for new server... (' + attempts + 's)';

                fetch('/api/stats', { cache: 'no-store' })
                    .then(r => r.json())
                    .then(data => {
                        // Check if this is a NEW server instance
                        if (data.session_id && data.session_id !== oldSessionId) {
                            statusEl.textContent = 'Server restarted! Reloading...';
                            setTimeout(() => location.reload(), 500);
                        } else {
                            // Still the old server, keep polling
                            statusEl.textContent = 'Waiting for restart... (' + attempts + 's)';
                            if (attempts >= maxAttempts) {
                                statusEl.textContent = 'Timeout - please refresh manually';
                                setTimeout(() => location.reload(), 2000);
                            } else {
                                setTimeout(poll, 1000);
                            }
                        }
                    })
                    .catch(() => {
                        // Server not responding (expected during restart)
                        if (attempts >= maxAttempts) {
                            statusEl.textContent = 'Timeout - please refresh manually';
                            setTimeout(() => location.reload(), 2000);
                        } else {
                            setTimeout(poll, 1000);
                        }
                    });
            };

            // Wait a moment for server to shut down, then start polling
            setTimeout(poll, 2000);
        }

        // Tab switching
        let currentTab = 'snapshot';

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tabs button').forEach(el => el.classList.remove('active'));
            document.getElementById('tab-' + tab).classList.add('active');
            event.target.classList.add('active');

            // Stop all streams when switching away
            if (tab !== 'mjpeg') stopMjpegStream();
            if (tab !== 'display') stopDisplayStream();
            if (tab !== 'flv') stopFlvPlayer();

            // Start the selected stream
            if (tab === 'snapshot') {
                const img = document.getElementById('preview-img');
                img.src = snapshotUrl + '?' + Date.now();
            } else if (tab === 'mjpeg') {
                startMjpegStream();
            } else if (tab === 'display') {
                startDisplayStream();
            }
            // FLV: don't auto-start, user clicks Play
        }

        // MJPEG stream
        function startMjpegStream() {
            const img = document.getElementById('mjpeg-stream');
            mjpegStreamError = false;
            img.onerror = () => { mjpegStreamError = true; };
            img.src = mjpegUrl;
            img.style.display = 'block';
            mjpegActive = true;
        }
        function stopMjpegStream() {
            const img = document.getElementById('mjpeg-stream');
            img.onerror = null;
            img.src = '';
            img.style.display = 'none';
            mjpegActive = false;
            mjpegStreamError = false;
            const mo = document.getElementById('mjpeg-overlay');
            if (mo) mo.style.display = 'none';
        }

        // Display stream (printer LCD framebuffer)
        let displayActive = false;
        const DISPLAY_WIDTH = 800;
        const DISPLAY_HEIGHT = 480;

        function startDisplayStream() {
            const img = document.getElementById('display-stream');
            img.src = displayUrl;
            img.style.display = 'block';
            img.style.cursor = 'crosshair';
            displayActive = true;
        }
        function stopDisplayStream() {
            const img = document.getElementById('display-stream');
            img.src = '';
            img.style.display = 'none';
            displayActive = false;
        }

        // Touch control for display stream
        function handleDisplayClick(event) {
            const img = event.target;
            const rect = img.getBoundingClientRect();

            // Calculate click position relative to image (0-1)
            const relX = (event.clientX - rect.left) / rect.width;
            const relY = (event.clientY - rect.top) / rect.height;

            // Scale to display coordinates
            const x = Math.round(relX * DISPLAY_WIDTH);
            const y = Math.round(relY * DISPLAY_HEIGHT);

            // Send touch command
            fetch('/api/touch', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({x: x, y: y, duration: 100})
            })
            .then(r => r.json())
            .then(data => {
                console.log('Touch:', data);
            })
            .catch(e => console.error('Touch error:', e));
        }

        // Initialize display click handler
        document.addEventListener('DOMContentLoaded', function() {
            const displayImg = document.getElementById('display-stream');
            if (displayImg) {
                displayImg.addEventListener('click', handleDisplayClick);
            }
        });

        // LED control
        function controlLed(on) {
            const btn = document.getElementById(on ? 'led-on-btn' : 'led-off-btn');
            fetch('/api/led/' + (on ? 'on' : 'off'))
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'ok') {
                        if (btn) {
                            btn.style.background = on ? '#4CAF50' : '#f44336';
                            setTimeout(() => { btn.style.background = ''; }, 1500);
                        }
                    } else {
                        if (btn) {
                            btn.style.background = '#f44336';
                            setTimeout(() => { btn.style.background = ''; }, 1500);
                        }
                        if (data.message) console.warn('LED:', data.message);
                    }
                })
                .catch(e => console.error('LED error:', e));
        }

        function updateLedButtons(mode) {
            const onBtn = document.getElementById('led-on-btn');
            const offBtn = document.getElementById('led-off-btn');
            const isVanilla = mode === 'vanilla-klipper';
            if (onBtn) { onBtn.disabled = isVanilla; onBtn.title = isVanilla ? 'LED control not available in vanilla-klipper mode' : ''; }
            if (offBtn) { offBtn.disabled = isVanilla; offBtn.title = isVanilla ? 'LED control not available in vanilla-klipper mode' : ''; }
        }

        // Camera controls
        let cameraControlsExpanded = false;
        let cameraControlsLoaded = false;

        function toggleCameraControls() {
            const panel = document.getElementById('camera-controls-panel');
            const arrow = document.getElementById('camera-controls-arrow');
            cameraControlsExpanded = !cameraControlsExpanded;
            panel.style.display = cameraControlsExpanded ? 'block' : 'none';
            arrow.innerHTML = cameraControlsExpanded ? '&#9660;' : '&#9654;';

            if (cameraControlsExpanded && !cameraControlsLoaded) {
                loadCameraControls();
            }
        }

        function loadCameraControls() {
            fetch('/api/camera/controls?camera_id=' + activeCameraId)
                .then(r => r.json())
                .then(data => {
                    // Update all sliders and selects with current values
                    Object.keys(data).forEach(key => {
                        const ctrl = data[key];
                        const el = document.getElementById('cam-' + key.replace(/_/g, '-'));
                        const valEl = document.getElementById('cam-' + key.replace(/_/g, '-') + '-val');

                        if (el) {
                            el.value = ctrl.value;
                            if (valEl) {
                                if (key === 'wb_temp') {
                                    valEl.textContent = ctrl.value + 'K';
                                } else {
                                    valEl.textContent = ctrl.value;
                                }
                            }
                        }
                    });
                    updateWbTempState();
                    cameraControlsLoaded = true;
                })
                .catch(e => console.error('Failed to load camera controls:', e));
        }

        function setCameraControl(control, value) {
            // Update display value immediately
            const valEl = document.getElementById('cam-' + control.replace(/_/g, '-') + '-val');
            if (valEl) {
                if (control === 'wb_temp') {
                    valEl.textContent = value + 'K';
                } else {
                    valEl.textContent = value;
                }
            }

            // Send to server with active camera ID
            fetch('/api/camera/set', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({control: control, value: parseInt(value), camera_id: activeCameraId})
            })
            .then(r => r.json())
            .then(data => {
                if (data.status !== 'ok') {
                    console.error('Camera control error:', data);
                }
            })
            .catch(e => console.error('Camera control error:', e));
        }

        function resetCameraDefaults() {
            if (!confirm('Reset all camera settings to defaults?')) return;

            fetch('/api/camera/reset', {method: 'POST'})
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'ok') {
                        cameraControlsLoaded = false;
                        loadCameraControls();
                    }
                })
                .catch(e => console.error('Reset error:', e));
        }

        function updateWbTempState() {
            const wbAuto = document.getElementById('cam-wb-auto');
            const wbTemp = document.getElementById('cam-wb-temp');
            if (wbAuto && wbTemp) {
                wbTemp.disabled = wbAuto.value === '1';
                wbTemp.style.opacity = wbAuto.value === '1' ? '0.5' : '1';
            }
        }

        // Open FLV in fullscreen window
        function openFlvFullscreen() {
            const w = screen.availWidth;
            const h = screen.availHeight;
            const flvStreamUrl = 'http://' + location.hostname + ':' + FLV_PORT + '/flv';
            const html = `<!DOCTYPE html>
<html><head><title>H.264 Stream</title>
<script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"><\/script>
<style>body{margin:0;background:#000;overflow:hidden}video{width:100vw;height:100vh;object-fit:contain}</style>
</head><body>
<video id="v" muted autoplay></video>
<script>
if(flvjs.isSupported()){
  var p=flvjs.createPlayer({type:'flv',isLive:true,url:'${flvStreamUrl}'},{enableWorker:false,enableStashBuffer:false});
  p.attachMediaElement(document.getElementById('v'));
  p.load();p.play();
}
<\/script></body></html>`;
            const win = window.open('', '_blank', 'width='+w+',height='+h);
            win.document.write(html);
            win.document.close();
        }

        // FLV player using flv.js
        function startFlvPlayer() {
            if (flvPlayerBusy) return;
            const statusEl = document.getElementById('flv-status');

            // Stop existing player first
            if (flvPlayer) {
                flvPlayerBusy = true;
                try {
                    flvPlayer.pause();
                    flvPlayer.unload();
                    flvPlayer.detachMediaElement();
                    flvPlayer.destroy();
                } catch(e) {}
                flvPlayer = null;
                // Wait a bit before creating new player
                setTimeout(createFlvPlayer, 200);
            } else {
                createFlvPlayer();
            }
        }

        function createFlvPlayer() {
            flvPlayerBusy = false;
            const statusEl = document.getElementById('flv-status');
            const videoElement = document.getElementById('flv-player');

            if (!flvjs.isSupported()) {
                statusEl.textContent = 'FLV.js not supported';
                return;
            }

            statusEl.textContent = 'Connecting...';

            flvPlayer = flvjs.createPlayer({
                type: 'flv',
                isLive: true,
                url: 'http://' + location.hostname + ':' + FLV_PORT + '/flv'
            }, {
                enableWorker: false,
                enableStashBuffer: false,
                stashInitialSize: 128,
                lazyLoad: false
            });

            flvPlayer.on(flvjs.Events.ERROR, (e, t) => {
                statusEl.textContent = 'Error: ' + t;
                const fo = document.getElementById('flv-overlay');
                if (fo) { fo.textContent = 'Stream error: ' + t; fo.className = 'stream-overlay error'; fo.style.display = ''; }
            });

            flvPlayer.on(flvjs.Events.LOADING_COMPLETE, () => {
                statusEl.textContent = 'Stream ended';
                const fo = document.getElementById('flv-overlay');
                if (fo) { fo.textContent = 'Stream ended'; fo.className = 'stream-overlay error'; fo.style.display = ''; }
            });

            flvPlayer.on(flvjs.Events.STATISTICS_INFO, (s) => {
                if (s.speed !== undefined) {
                    flvBitrateKbps = Math.round(s.speed * 8);
                }
            });

            flvPlayer.attachMediaElement(videoElement);
            flvPlayer.load();

            // Handle play promise properly
            const playPromise = videoElement.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    statusEl.textContent = 'Playing';
                }).catch(err => {
                    statusEl.textContent = 'Click Play';
                });
            }
        }

        function stopFlvPlayer() {
            if (flvPlayerBusy) return;
            const statusEl = document.getElementById('flv-status');
            const videoElement = document.getElementById('flv-player');

            if (flvPlayer) {
                flvPlayerBusy = true;
                try {
                    videoElement.pause();
                    flvPlayer.unload();
                    flvPlayer.detachMediaElement();
                    flvPlayer.destroy();
                } catch(e) {}
                flvPlayer = null;
                flvPlayerBusy = false;
            }
            statusEl.textContent = 'Stopped';
            flvBitrateKbps = 0;
            const fo = document.getElementById('flv-overlay');
            if (fo) fo.style.display = 'none';
        }

        // FPS percentage helpers
        let currentMjpegFps = 20;  // Will be updated from stats
        let currentMaxCameraFps = $max_camera_fps;
        let savedSkipRatio = $skip_ratio;

        function pctToSkipRatio(pct) {
            // 100% = skip_ratio 1 (all frames)
            // 0% = skip_ratio = mjpegFps (1 fps output)
            if (pct <= 0) return Math.max(1, Math.round(currentMjpegFps));
            if (pct >= 100) return 1;
            return Math.max(1, Math.round(100 / pct));
        }

        function skipRatioToPct(ratio) {
            if (ratio <= 1) return 100;
            return Math.max(1, Math.min(100, Math.round(100 / ratio)));
        }

        function updateFpsLabel() {
            const pct = parseInt(document.getElementById('fps_pct_input').value) || 0;
            const skipRatio = pctToSkipRatio(pct);
            const estFps = (currentMjpegFps / skipRatio).toFixed(1);
            document.getElementById('fps_label').textContent = '~' + estFps + ' fps';
            document.getElementById('skip_ratio_hidden').value = skipRatio;
        }

        function updateMjpegFpsLabel() {
            const label = document.getElementById('mjpeg_fps_label');
            label.textContent = '(Camera source rate)';
            label.style.color = '#888';
        }

        function toggleAutoSkip(enabled) {
            document.getElementById('fps_pct_slider').disabled = enabled;
            document.getElementById('fps_pct_input').disabled = enabled;
            document.querySelector('[name=target_cpu]').disabled = !enabled;

            // When disabling auto-skip, restore the saved manual setting
            if (!enabled) {
                const pct = skipRatioToPct(savedSkipRatio);
                document.getElementById('fps_pct_slider').value = pct;
                document.getElementById('fps_pct_input').value = pct;
                document.getElementById('skip_ratio_hidden').value = savedSkipRatio;
                updateFpsLabel();
            }
        }

        function toggleProxySettings(proxyEnabled) {
            document.querySelectorAll('.h264-local-setting').forEach(el => {
                el.style.display = proxyEnabled ? 'none' : '';
            });
            updateStatusPorts();
        }

        function updateDisplaySettings() {
            const enabled = document.querySelector('[name=display_enabled]').checked;
            document.getElementById('display_fps_select').disabled = !enabled;
            updateStatusPorts();
        }

        // Timelapse settings UI functions
        function updateTimelapseSettings() {
            const enabled = document.getElementById('timelapse_enabled').checked;
            document.querySelectorAll('.timelapse-setting').forEach(el => {
                el.style.display = enabled ? '' : 'none';
            });
            if (enabled) {
                updateTimelapseModeSettings();
                updateVariableFpsSettings();
                checkUsbStatus();
            }
        }

        function updateTimelapseModeSettings() {
            const mode = document.getElementById('timelapse_mode').value;
            document.querySelectorAll('.hyperlapse-only').forEach(el => {
                el.style.display = mode === 'hyperlapse' ? '' : 'none';
            });
        }

        function updateVariableFpsSettings() {
            const enabled = document.getElementById('timelapse_variable_fps')?.checked || false;
            document.querySelectorAll('.variable-fps-setting').forEach(el => {
                el.style.display = enabled ? '' : 'none';
            });
        }

        function checkUsbStatus() {
            fetch('/api/timelapse/storage')
                .then(r => r.json())
                .then(data => {
                    const statusEl = document.getElementById('usb_status');
                    if (data.usb_mounted) {
                        statusEl.innerHTML = '&bull; Mounted';
                        statusEl.style.color = '#4CAF50';
                    } else {
                        statusEl.innerHTML = 'o Not detected';
                        statusEl.style.color = '#888';
                    }
                })
                .catch(() => {
                    const statusEl = document.getElementById('usb_status');
                    statusEl.textContent = '? Unknown';
                    statusEl.style.color = '#f90';
                });
        }

        function checkMoonrakerStatus() {
            fetch('/api/timelapse/moonraker')
                .then(r => r.json())
                .then(data => {
                    const statusEl = document.getElementById('moonraker_status');
                    if (data.connected) {
                        statusEl.innerHTML = '&bull; Connected';
                        statusEl.style.color = '#4CAF50';
                        if (data.print_state && data.print_state !== 'standby') {
                            statusEl.innerHTML += ' (' + data.print_state + ')';
                        }
                    } else {
                        statusEl.innerHTML = 'o Disconnected';
                        statusEl.style.color = '#888';
                    }
                    updateTlEncodeDot(data.timelapse_encode_status, data.timelapse_encode_detail);
                })
                .catch(() => {
                    const statusEl = document.getElementById('moonraker_status');
                    statusEl.innerHTML = '? Unknown';
                    statusEl.style.color = '#f90';
                });
        }

        function updateTlEncodeDot(status, detail) {
            const dot = document.getElementById('tl-encode-dot');
            if (!dot) return;
            if (!status || status === 'idle') {
                dot.style.display = 'none';
                dot.style.animation = '';
                return;
            }
            dot.style.display = 'inline';
            dot.title = detail || status;
            switch (status) {
                case 'pending':
                    dot.style.color = '#f90';
                    dot.style.animation = '';
                    break;
                case 'running':
                    dot.style.color = '#4CAF50';
                    dot.style.animation = 'tl-blink 1s infinite';
                    break;
                case 'success':
                    dot.style.color = '#4CAF50';
                    dot.style.animation = '';
                    break;
                case 'failed':
                    dot.style.color = '#f44336';
                    dot.style.animation = '';
                    break;
            }
        }

        function updateStorageSettings() {
            const storage = document.getElementById('timelapse_storage').value;
            document.querySelectorAll('.usb-path-setting').forEach(el => {
                el.style.display = storage === 'usb' ? '' : 'none';
            });
        }

        // Folder picker for USB path
        let folderPickerModal = null;
        let currentPickerPath = '/mnt/udisk';

        function openFolderPicker() {
            if (!folderPickerModal) {
                folderPickerModal = document.createElement('div');
                folderPickerModal.id = 'folder-picker-modal';
                folderPickerModal.innerHTML = `
                    <div style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;display:flex;align-items:center;justify-content:center;">
                        <div style="background:#222;border-radius:8px;padding:20px;width:400px;max-width:90%;max-height:80vh;display:flex;flex-direction:column;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
                                <h3 style="margin:0;">Select Folder</h3>
                                <button onclick="closeFolderPicker()" style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">&times;</button>
                            </div>
                            <div id="picker-path" style="font-family:monospace;background:#333;padding:8px;border-radius:4px;margin-bottom:10px;word-break:break-all;"></div>
                            <div id="picker-list" style="flex:1;overflow-y:auto;border:1px solid #444;border-radius:4px;min-height:200px;max-height:300px;"></div>
                            <div style="display:flex;gap:10px;margin-top:15px;">
                                <button onclick="createNewFolder()" class="secondary" style="flex:1;">New Folder</button>
                                <button onclick="selectCurrentFolder()" style="flex:1;">Select This Folder</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(folderPickerModal);
            }
            folderPickerModal.style.display = 'block';
            currentPickerPath = '/mnt/udisk';
            loadFolderContents(currentPickerPath);
        }

        function closeFolderPicker() {
            if (folderPickerModal) {
                folderPickerModal.style.display = 'none';
            }
        }

        function loadFolderContents(path) {
            currentPickerPath = path;
            document.getElementById('picker-path').textContent = path;
            document.getElementById('picker-list').innerHTML = '<div style="padding:20px;text-align:center;color:#888;">Loading...</div>';

            fetch('/api/timelapse/browse?path=' + encodeURIComponent(path))
                .then(r => r.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById('picker-list').innerHTML = '<div style="padding:20px;text-align:center;color:#f44;">Error: ' + data.error + '</div>';
                        return;
                    }
                    const listEl = document.getElementById('picker-list');
                    listEl.innerHTML = '';

                    // Parent directory link
                    if (path !== '/mnt/udisk') {
                        const parent = path.substring(0, path.lastIndexOf('/')) || '/mnt/udisk';
                        const parentDiv = document.createElement('div');
                        parentDiv.style.cssText = 'padding:10px;cursor:pointer;border-bottom:1px solid #333;display:flex;align-items:center;gap:10px;';
                        parentDiv.innerHTML = '<span>&#128194;</span> <span>..</span>';
                        parentDiv.onmouseover = function() { this.style.background='#333'; };
                        parentDiv.onmouseout = function() { this.style.background=''; };
                        parentDiv.onclick = function() { loadFolderContents(parent); };
                        listEl.appendChild(parentDiv);
                    }

                    // Folder entries
                    if (data.folders && data.folders.length > 0) {
                        data.folders.forEach(function(folder) {
                            const fullPath = path + '/' + folder;
                            const div = document.createElement('div');
                            div.style.cssText = 'padding:10px;cursor:pointer;border-bottom:1px solid #333;display:flex;align-items:center;gap:10px;';
                            div.innerHTML = '<span>&#128193;</span> <span>' + folder + '</span>';
                            div.onmouseover = function() { this.style.background='#333'; };
                            div.onmouseout = function() { this.style.background=''; };
                            div.onclick = function() { loadFolderContents(fullPath); };
                            listEl.appendChild(div);
                        });
                    }

                    if (listEl.children.length === 0) {
                        listEl.innerHTML = '<div style="padding:20px;text-align:center;color:#888;">Empty folder</div>';
                    }
                })
                .catch(err => {
                    document.getElementById('picker-list').innerHTML = '<div style="padding:20px;text-align:center;color:#f44;">Failed to load</div>';
                });
        }

        function selectCurrentFolder() {
            document.getElementById('timelapse_usb_path').value = currentPickerPath;
            closeFolderPicker();
        }

        function createNewFolder() {
            const name = prompt('Enter new folder name:');
            if (!name) return;
            fetch('/api/timelapse/mkdir', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({path: currentPickerPath + '/' + name})
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    loadFolderContents(currentPickerPath);
                } else {
                    alert('Failed to create folder: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(() => alert('Failed to create folder'));
        }

        // Update stats every second
        function updateStats() {
            fetch('/api/stats')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('stat-cpu-total').textContent = data.cpu.total + '%';
                    document.getElementById('stat-mjpeg-fps').textContent = data.fps.mjpeg;
                    document.getElementById('stat-h264-fps').textContent = data.fps.h264;
                    document.getElementById('stat-cpu-encoder').textContent = data.encoder_cpu + '%';
                    document.getElementById('stat-cpu-streamer').textContent = data.streamer_cpu + '%';
                    // Update client count
                    if (data.clients) {
                        const totalClients = (data.clients.mjpeg || 0) + (data.clients.flv || 0);
                        document.getElementById('stat-clients').textContent = totalClients;
                    }
                    // Update MJPEG FPS for percentage calculations
                    if (data.fps.mjpeg > 0) {
                        currentMjpegFps = data.fps.mjpeg;
                        updateFpsLabel();
                    }
                    // Keep saved_skip_ratio in sync with server
                    if (data.saved_skip_ratio) {
                        savedSkipRatio = data.saved_skip_ratio;
                    }
                    // Update slider only if auto_skip checkbox is CHECKED (local UI state)
                    const autoSkipCheckbox = document.querySelector('[name=auto_skip]');
                    if (autoSkipCheckbox && autoSkipCheckbox.checked) {
                        const pct = skipRatioToPct(data.skip_ratio);
                        document.getElementById('fps_pct_slider').value = pct;
                        document.getElementById('fps_pct_input').value = pct;
                        document.getElementById('skip_ratio_hidden').value = data.skip_ratio;
                        updateFpsLabel();
                    }
                    // Update stream overlays
                    updateStreamOverlays(data);
                    // Update fault detection status
                    if (data.fault_detect) updateFdStatus(data.fault_detect);
                })
                .catch(() => {
                    // Stats fetch failed  encoder likely down
                    const mo = document.getElementById('mjpeg-overlay');
                    if (mjpegActive && mo) {
                        mo.textContent = 'Stream disconnected';
                        mo.className = 'stream-overlay error';
                        mo.style.display = '';
                    }
                });
        }

        let mjpegStreamError = false;
        let flvBitrateKbps = 0;
        let prevFlvBytes = 0;
        let prevFlvTime = 0;

        function updateStreamOverlays(data) {
            // MJPEG overlay
            const mo = document.getElementById('mjpeg-overlay');
            if (mjpegActive && mo) {
                const fps = data.fps.mjpeg;
                if (mjpegStreamError || fps <= 0) {
                    mo.textContent = mjpegStreamError ? 'Stream error' : 'No stream';
                    mo.className = 'stream-overlay error';
                } else {
                    mo.textContent = fps + ' fps';
                    mo.className = 'stream-overlay';
                }
                mo.style.display = '';
            } else if (mo) {
                mo.style.display = 'none';
            }

            // FLV overlay
            const fo = document.getElementById('flv-overlay');
            if (flvPlayer && fo) {
                const fps = data.fps.h264;
                let text = fps + ' fps';
                if (flvBitrateKbps > 0) text += ' / ' + flvBitrateKbps + ' kbps';
                if (fps <= 0) {
                    fo.textContent = 'No stream';
                    fo.className = 'stream-overlay error';
                } else {
                    fo.textContent = text;
                    fo.className = 'stream-overlay';
                }
                fo.style.display = '';
            } else if (fo) {
                fo.style.display = 'none';
            }
        }

        // Start stats update - poll every 2 seconds to reduce CPU
        if (!statsInterval) {
            statsInterval = setInterval(updateStats, 2000);
        }
        // Initialize FPS labels on load
        updateFpsLabel();
        updateMjpegFpsLabel();

        // Handle form submission
        document.getElementById('settings-form').addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const data = new URLSearchParams();
            data.append('encoder_type', document.querySelector('[name=encoder_type]').value);
            data.append('autolanmode', formData.has('autolanmode') ? '1' : '0');
            data.append('logging', formData.has('logging') ? '1' : '0');
            data.append('log_max_size', document.querySelector('[name=log_max_size]').value);
            data.append('h264_enabled', formData.has('h264_enabled') ? '1' : '0');
            data.append('skip_ratio', document.querySelector('[name=skip_ratio]').value);
            data.append('auto_skip', formData.has('auto_skip') ? '1' : '0');
            data.append('target_cpu', document.querySelector('[name=target_cpu]').value);
            data.append('bitrate', document.querySelector('[name=bitrate]').value);
            data.append('h264_resolution', document.querySelector('[name=h264_resolution]')?.value || '1280x720');
            // Get mjpeg_fps from the correct slider based on encoder type
            const selectedEncoderType = document.querySelector('[name=encoder_type]').value;
            const mjpegFpsValue = selectedEncoderType === 'rkmpi-yuyv'
                ? document.getElementById('mjpeg_fps_slider_yuyv').value
                : document.getElementById('mjpeg_fps_slider').value;
            data.append('mjpeg_fps', mjpegFpsValue);
            // Display capture settings
            if (formData.has('display_enabled')) {
                data.append('display_enabled', 'on');
            }
            data.append('display_fps', document.querySelector('[name=display_fps]').value);
            // ACProxyCam FLV proxy
            if (formData.has('acproxycam_flv_proxy')) {
                data.append('acproxycam_flv_proxy', '1');
            }

            // Check if settings require restart (only camera resolution still needs it)
            const newH264Resolution = document.querySelector('[name=h264_resolution]')?.value || '1280x720';
            const needsRestart = (newH264Resolution !== currentH264Resolution) &&
                (currentEncoderType === 'rkmpi' || currentEncoderType === 'rkmpi-yuyv');

            if (needsRestart) {
                // Show loading overlay and trigger restart
                const overlay = document.getElementById('loading-overlay');
                const statusEl = document.getElementById('loading-status');
                overlay.classList.add('active');
                statusEl.textContent = 'Saving settings...';

                // Stop stats polling during restart to avoid connection errors
                if (statsInterval) {
                    clearInterval(statsInterval);
                    statsInterval = null;
                }

                fetch('/control', {
                    method: 'POST',
                    body: data
                }).then(() => {
                    statusEl.textContent = 'Restarting encoder...';
                    return fetch('/api/restart');
                }).then(() => {
                    statusEl.textContent = 'Waiting for encoder...';
                    pollForRestart();
                }).catch(err => {
                    overlay.classList.remove('active');
                    alert('Restart failed: ' + err);
                });
            } else {
                fetch('/control', {
                    method: 'POST',
                    body: data
                }).then(() => location.reload());
            }
        });

        // Timelapse form submission
        const timelapseForm = document.getElementById('timelapse-form');
        if (timelapseForm) {
            timelapseForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const formData = new FormData(this);
                const data = new URLSearchParams();

                // Boolean settings
                data.append('timelapse_enabled', formData.has('timelapse_enabled') ? '1' : '0');
                data.append('timelapse_variable_fps', formData.has('timelapse_variable_fps') ? '1' : '0');
                data.append('timelapse_flip_x', formData.has('timelapse_flip_x') ? '1' : '0');
                data.append('timelapse_flip_y', formData.has('timelapse_flip_y') ? '1' : '0');

                // String/number settings
                data.append('timelapse_mode', formData.get('timelapse_mode') || 'layer');
                data.append('timelapse_hyperlapse_interval', formData.get('timelapse_hyperlapse_interval') || '30');
                data.append('timelapse_storage', formData.get('timelapse_storage') || 'internal');
                data.append('timelapse_usb_path', formData.get('timelapse_usb_path') || '/mnt/udisk/timelapse');
                data.append('timelapse_output_fps', formData.get('timelapse_output_fps') || '30');
                data.append('timelapse_target_length', formData.get('timelapse_target_length') || '10');
                data.append('timelapse_variable_fps_min', formData.get('timelapse_variable_fps_min') || '5');
                data.append('timelapse_variable_fps_max', formData.get('timelapse_variable_fps_max') || '60');
                data.append('timelapse_crf', formData.get('timelapse_crf') || '23');
                data.append('timelapse_duplicate_last_frame', formData.get('timelapse_duplicate_last_frame') || '0');
                data.append('timelapse_stream_delay', formData.get('timelapse_stream_delay') || '0.05');
                data.append('timelapse_end_delay', formData.get('timelapse_end_delay') || '5.0');

                fetch('/api/timelapse/settings', {
                    method: 'POST',
                    body: data
                }).then(r => r.json())
                .then(data => {
                    if (data.status === 'ok') {
                        // Refresh status indicators
                        checkUsbStatus();
                        alert('Timelapse settings saved');
                    } else {
                        alert('Error saving settings: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(err => alert('Error: ' + err));
            });
        }

        // Initialize UI on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateEncoderVisibility();
            updateTimelapseSettings();
            // Hide H.264 local settings when ACProxyCam FLV proxy is enabled
            const proxyCheckbox = document.querySelector('[name=acproxycam_flv_proxy]');
            if (proxyCheckbox) {
                toggleProxySettings(proxyCheckbox.checked);
            }
            // Apply auto-skip UI state on load (disable slider when auto-skip is on)
            const autoSkipCheckbox = document.querySelector('[name=auto_skip]');
            if (autoSkipCheckbox) {
                toggleAutoSkip(autoSkipCheckbox.checked);
            }
            // Check mode to disable LED buttons in vanilla-klipper
            fetch('/api/config').then(r => r.json()).then(data => {
                if (data.mode) updateLedButtons(data.mode);
            }).catch(() => {});
        });

        // Snapshot preview is static - click image to refresh (reduces CPU usage)

        // ============================================================
        // Fault Detection
        // ============================================================

        let lastFdFrameCycle = 0;

        function drawFdOverlay(heatmap) {
            const canvas = document.getElementById('fd-heatmap-canvas');
            const info = document.getElementById('fd-heatmap-info');
            const row = document.getElementById('fd-heatmap-row');
            const img = document.getElementById('fd-frame-img');
            if (!canvas || !row) return;

            if (!heatmap || !heatmap.has_data || !heatmap.grid) {
                row.style.display = 'none';
                return;
            }

            row.style.display = '';
            const grid = heatmap.grid;
            const rows = grid.length;
            const cols = rows > 0 ? grid[0].length : 0;

            // Size canvas to match displayed image
            const imgW = img.naturalWidth || 320;
            const imgH = img.naturalHeight || 180;
            canvas.width = imgW;
            canvas.height = imgH;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, imgW, imgH);

            const crop = heatmap.crop || { x: 0, y: 0, w: 1, h: 1 };

            // Crop region in pixel coords
            const cx = crop.x * imgW;
            const cy = crop.y * imgH;
            const cw = crop.w * imgW;
            const ch = crop.h * imgH;
            const cellW = cw / cols;
            const cellH = ch / rows;

            // Fixed scale centered at 0: negative=OK(green), positive=FAULT(red)
            // Cosine margin space: -1.0 = deeply OK, +1.0 = deeply FAULT
            const HEATMAP_SCALE = 1.0;
            let vmin = Infinity, vmax = -Infinity;
            for (let h = 0; h < rows; h++) {
                for (let w = 0; w < cols; w++) {
                    const v = grid[h][w];
                    if (v < vmin) vmin = v;
                    if (v > vmax) vmax = v;
                }
            }

            ctx.globalAlpha = 0.45;
            for (let h = 0; h < rows; h++) {
                for (let w = 0; w < cols; w++) {
                    const v = grid[h][w];
                    // Fixed scale: v=-1t=0(green), v=0t=0.5(yellow), v=+1t=1(red)
                    const t = Math.max(0, Math.min(1, (v / HEATMAP_SCALE + 1) / 2));
                    let r, g, b;
                    if (t < 0.5) {
                        // green to yellow
                        const s = t * 2;
                        r = Math.round(s * 255);
                        g = 200;
                        b = Math.round((1 - s) * 60);
                    } else {
                        // yellow to red
                        const s = (t - 0.5) * 2;
                        r = 255;
                        g = Math.round((1 - s) * 200);
                        b = 0;
                    }
                    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.fillRect(cx + w * cellW, cy + h * cellH, cellW, cellH);
                }
            }
            ctx.globalAlpha = 1.0;

            // Max cell marker
            if (heatmap.max_row >= 0 && heatmap.max_col >= 0) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    cx + heatmap.max_col * cellW + 1,
                    cy + heatmap.max_row * cellH + 1,
                    cellW - 2, cellH - 2
                );
            }

            if (info) {
                info.textContent = 'max=' + heatmap.max.toFixed(3) +
                    ' at [' + heatmap.max_row + ',' + heatmap.max_col + ']' +
                    ' range=[' + vmin.toFixed(3) + ',' + vmax.toFixed(3) + ']';
            }
        }

        function updateFdStatus(fd) {
            const statusEl = document.getElementById('fd-status');
            const detEl = document.getElementById('fd-detection');
            const confRow = document.getElementById('fd-confidence-row');
            const confEl = document.getElementById('fd-confidence');
            const timingRow = document.getElementById('fd-timing-row');
            const timingEl = document.getElementById('fd-timing');
            const classRow = document.getElementById('fd-class-row');
            const classEl = document.getElementById('fd-class');

            if (!statusEl) return;

            // NPU availability
            if (!fd.npu_available) {
                statusEl.textContent = 'NPU not available';
                statusEl.style.color = '#888';
                document.getElementById('fd-npu-warning').hidden = false;
                const fdEn = document.getElementById('fd_enabled');
                if (fdEn) fdEn.disabled = true;
                return;
            }

            // Status text and color
            const statusMap = {
                'disabled': { text: 'Disabled', color: '#888' },
                'enabled':  { text: 'Active', color: '#4a4' },
                'active':   { text: 'Running...', color: '#4af' },
                'error':    { text: 'Error', color: '#f44' },
                'no_npu':   { text: 'NPU not available', color: '#888' },
                'mem_low':  { text: 'Memory low', color: '#fa4' }
            };
            const s = statusMap[fd.status] || { text: fd.status, color: '#888' };
            statusEl.textContent = s.text;
            statusEl.style.color = s.color;

            // Detection result
            if (fd.status === 'enabled' || fd.status === 'active') {
                if (fd.detection === 'fault') {
                    detEl.textContent = 'FAULT DETECTED';
                    detEl.style.color = '#f44';
                    detEl.style.fontWeight = 'bold';
                } else {
                    detEl.textContent = 'OK';
                    detEl.style.color = '#4a4';
                    detEl.style.fontWeight = 'normal';
                }

                // Confidence
                if (fd.confidence > 0) {
                    confRow.style.display = '';
                    confEl.textContent = (fd.confidence * 100).toFixed(1) + '%';
                }

                // Per-model detail
                const modelsRow = document.getElementById('fd-models-row');
                const modelsEl = document.getElementById('fd-models');
                if (fd.models && Object.keys(fd.models).length > 1) {
                    const names = { cnn: 'CNN', proto: 'Proto', multi: 'Multi' };
                    const lines = [];
                    for (const [key, m] of Object.entries(fd.models)) {
                        const name = names[key] || key;
                        const rawPct = (m.raw * 100).toFixed(1);
                        const lkPct = (m.fault_lk * 100).toFixed(1);
                        let line = name + ': ' + rawPct + '% raw, ' + lkPct + '% norm (' + m.ms + 'ms)';
                        if (key !== 'multi') {
                            const vote = m.vote === 'fault' ? 'KO' : 'OK';
                            const voteColor = m.vote === 'fault' ? '#f55' : '#5f5';
                            line += ' <span style="color:' + voteColor + ';font-weight:bold">(' + vote + ')</span>';
                        }
                        lines.push(line);
                    }
                    if (fd.boost && fd.boost.active) {
                        const isFault = fd.detection === 'fault';
                        const boostLabel = isFault ? 'KO' : 'OK';
                        const boostColor = fd.boost.overrode ? '#f55' : (isFault ? '#fa0' : '#5f5');
                        lines.push('Boost: heatmap ' + (fd.boost.heatmap_max * 100).toFixed(0) + '%, ' + fd.boost.strong_cells + '/' + fd.boost.total_cells + ' cells <span style="color:' + boostColor + ';font-weight:bold">(' + boostLabel + ')</span>');
                    }
                    modelsRow.style.display = '';
                    modelsEl.innerHTML = lines.join('\n');
                } else if (modelsRow) {
                    modelsRow.style.display = 'none';
                }

                // Fault class
                if (fd.detection === 'fault' && fd.fault_class && fd.fault_class !== '-') {
                    classRow.style.display = '';
                    classEl.textContent = fd.fault_class === 'Success' ? 'Not detected' : fd.fault_class;
                } else {
                    classRow.style.display = 'none';
                }

                // Timing
                if (fd.inference_ms > 0) {
                    timingRow.style.display = '';
                    timingEl.textContent = fd.inference_ms + ' ms';
                }

                // Heatmap overlay on FD frame
                if (fd.heatmap && fd.heatmap.has_data) {
                    const newCycle = fd.cycle_count || 0;
                    if (newCycle !== lastFdFrameCycle) {
                        lastFdFrameCycle = newCycle;
                        const fdImg = document.getElementById('fd-frame-img');
                        if (fdImg) {
                            fdImg.onload = function() { drawFdOverlay(fd.heatmap); };
                            fdImg.src = '/api/fault_detect/frame?t=' + newCycle;
                        }
                    } else {
                        drawFdOverlay(fd.heatmap);
                    }
                } else {
                    const hmRow = document.getElementById('fd-heatmap-row');
                    if (hmRow) hmRow.style.display = 'none';
                }
            } else {
                detEl.textContent = '-';
                detEl.style.color = '#ccc';
                detEl.style.fontWeight = 'normal';
                confRow.style.display = 'none';
                timingRow.style.display = 'none';
                classRow.style.display = 'none';
                const mdRow = document.getElementById('fd-models-row');
                if (mdRow) mdRow.style.display = 'none';
                const hmRow = document.getElementById('fd-heatmap-row');
                if (hmRow) hmRow.style.display = 'none';
            }
        }

        // Fault Detection: Model Sets + Thresholds
        window.fdSetsData = [];
        window.fdCurrentSet = null;

        function updateFdVisibility() {
            /* No-op: settings always visible and usable regardless of enable state. */
        }

        function loadFdSets() {
            fetch('/api/fault_detect/sets')
                .then(r => r.json())
                .then(data => {
                    if (!data.sets) return;
                    window.fdSetsData = data.sets;

                    const sel = document.getElementById('fd_model_set');
                    if (!sel) return;
                    sel.innerHTML = '';

                    if (data.sets.length === 0) {
                        sel.innerHTML = '<option value="">No model sets found</option>';
                        return;
                    }

                    // Get saved model_set from template
                    const savedSet = '$fd_model_set';
                    const hasSaved = savedSet && savedSet !== '$' + 'fd_model_set';

                    data.sets.forEach(s => {
                        const opt = document.createElement('option');
                        opt.value = s.dir_name;
                        opt.textContent = s.display_name;
                        if (s.selected || (hasSaved && s.dir_name === savedSet)) opt.selected = true;
                        sel.appendChild(opt);
                    });

                    // If no selection, select first
                    if (!sel.value && data.sets.length > 0)
                        sel.value = data.sets[0].dir_name;

                    onFdSetChange();
                })
                .catch(() => {
                    const sel = document.getElementById('fd_model_set');
                    if (sel) sel.innerHTML = '<option value="">Failed to load</option>';
                });
        }

        function onFdSetChange() {
            const sel = document.getElementById('fd_model_set');
            const setName = sel ? sel.value : '';
            const setData = window.fdSetsData.find(s => s.dir_name === setName);
            window.fdCurrentSet = setData;

            const container = document.getElementById('fd-models-container');
            const list = document.getElementById('fd-models-list');
            const thSection = document.getElementById('fd-threshold-section');

            if (!setData) {
                if (container) container.style.display = 'none';
                if (thSection) thSection.style.display = 'none';
                return;
            }

            // Show model list (informational, strategy controls which models are used)
            let html = '';
            if (setData.has_cnn) {
                const dn = setData.cnn_display_name || 'CNN';
                html += '<div style="padding:2px 0;font-size:12px;"><span style="color:#6b6;">&#x25cf;</span> <strong>CNN:</strong> ' + dn + '</div>';
            }
            if (setData.has_protonet) {
                const dn = setData.proto_display_name || 'ProtoNet';
                html += '<div style="padding:2px 0;font-size:12px;"><span style="color:#6b6;">&#x25cf;</span> <strong>ProtoNet:</strong> ' + dn + '</div>';
            }
            if (setData.has_multiclass) {
                const dn = setData.multi_display_name || 'Multiclass';
                html += '<div style="padding:2px 0;font-size:12px;"><span style="color:#6b6;">&#x25cf;</span> <strong>Multiclass:</strong> ' + dn + '</div>';
            }

            if (list) list.innerHTML = html;
            if (container) container.style.display = html ? '' : 'none';

            // Show threshold rows based on available models
            document.getElementById('fd-th-cnn-row').style.display = setData.has_cnn ? '' : 'none';
            document.getElementById('fd-th-proto-row').style.display = setData.has_protonet ? '' : 'none';
            document.getElementById('fd-th-multi-row').style.display = setData.has_multiclass ? '' : 'none';

            // Populate profiles dropdown
            const profSel = document.getElementById('fd_profile');
            profSel.innerHTML = '';
            const profKeys = Object.keys(setData.profiles || {});
            profKeys.forEach(k => {
                const opt = document.createElement('option');
                opt.value = k;
                opt.textContent = k + (setData.profiles[k].description ? ' - ' + setData.profiles[k].description : '');
                profSel.appendChild(opt);
            });

            // Show threshold section if profiles exist
            if (thSection) thSection.style.display = profKeys.length > 0 ? '' : 'none';

            // Apply saved threshold_config if this set is selected
            const customCb = document.getElementById('fd_custom');
            if (setData.threshold_config) {
                const tc = setData.threshold_config;
                if (tc.profile && profSel.querySelector('option[value="' + tc.profile + '"]'))
                    profSel.value = tc.profile;
                customCb.checked = (tc.mode === 'custom');
                setThresholdInputs(tc);
                toggleThresholdEditable(tc.mode === 'custom');
            } else if (profKeys.length > 0) {
                customCb.checked = false;
                onFdProfileChange();
            }
        }

        function setThresholdInputs(vals) {
            const ids = {
                'fd_th_cnn': 'cnn_threshold', 'fd_th_cnn_dyn': 'cnn_dynamic_threshold',
                'fd_th_proto': 'proto_threshold', 'fd_th_proto_trig': 'proto_dynamic_trigger',
                'fd_th_multi': 'multi_threshold', 'fd_th_heatmap': 'heatmap_boost_threshold',
                'fd_th_boost_min_cells': 'boost_min_cells',
                'fd_th_boost_cell_th': 'boost_cell_threshold',
                'fd_th_boost_lean': 'boost_lean_factor',
                'fd_th_boost_proto_lean': 'boost_proto_lean',
                'fd_th_boost_multi_lean': 'boost_multi_lean',
                'fd_th_boost_proto_veto': 'boost_proto_veto',
                'fd_th_boost_proto_strong': 'boost_proto_strong',
                'fd_th_boost_amp_cap': 'boost_amplifier_cap',
                'fd_th_boost_conf_cap': 'boost_confidence_cap',
                'fd_th_ema_alpha': 'ema_alpha',
                'fd_th_coarse_wt': 'heatmap_coarse_weight'
            };
            for (const [id, key] of Object.entries(ids)) {
                const el = document.getElementById(id);
                if (el && vals[key] !== undefined) el.value = Math.round(vals[key] * 100) / 100;
            }
        }

        function toggleThresholdEditable(editable) {
            ['fd_th_cnn','fd_th_cnn_dyn','fd_th_proto','fd_th_proto_trig','fd_th_multi','fd_th_heatmap',
             'fd_th_boost_min_cells','fd_th_boost_cell_th','fd_th_boost_lean',
             'fd_th_boost_proto_lean','fd_th_boost_multi_lean','fd_th_boost_proto_veto',
             'fd_th_boost_proto_strong','fd_th_boost_amp_cap','fd_th_boost_conf_cap',
             'fd_th_ema_alpha','fd_th_coarse_wt'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.disabled = !editable;
                    el.style.opacity = editable ? '1' : '0.6';
                    el.style.cursor = editable ? 'text' : 'default';
                    el.style.borderColor = editable ? '#666' : '#444';
                }
            });
        }

        function onFdProfileChange() {
            const profSel = document.getElementById('fd_profile');
            const set = window.fdCurrentSet;
            if (!set || !profSel.value) return;

            const prof = (set.profiles || {})[profSel.value];
            if (prof) {
                setThresholdInputs(prof);
                toggleThresholdEditable(document.getElementById('fd_custom').checked);
            }
        }

        function onFdCustomToggle() {
            const custom = document.getElementById('fd_custom').checked;
            toggleThresholdEditable(custom);
            if (!custom) {
                // Revert to profile values
                onFdProfileChange();
            }
        }

        function getThresholdValues() {
            return {
                cnn_threshold: parseFloat(document.getElementById('fd_th_cnn').value) || 0,
                cnn_dynamic_threshold: parseFloat(document.getElementById('fd_th_cnn_dyn').value) || 0,
                proto_threshold: parseFloat(document.getElementById('fd_th_proto').value) || 0,
                proto_dynamic_trigger: parseFloat(document.getElementById('fd_th_proto_trig').value) || 0,
                multi_threshold: parseFloat(document.getElementById('fd_th_multi').value) || 0,
                heatmap_boost_threshold: parseFloat(document.getElementById('fd_th_heatmap').value) || 0,
                boost_min_cells: parseInt(document.getElementById('fd_th_boost_min_cells').value) || 0,
                boost_cell_threshold: parseFloat(document.getElementById('fd_th_boost_cell_th').value) || 0,
                boost_lean_factor: parseFloat(document.getElementById('fd_th_boost_lean').value) || 0,
                boost_proto_lean: parseFloat(document.getElementById('fd_th_boost_proto_lean').value) || 0,
                boost_multi_lean: parseFloat(document.getElementById('fd_th_boost_multi_lean').value) || 0,
                boost_proto_veto: parseFloat(document.getElementById('fd_th_boost_proto_veto').value) || 0,
                boost_proto_strong: parseFloat(document.getElementById('fd_th_boost_proto_strong').value) || 0,
                boost_amplifier_cap: parseFloat(document.getElementById('fd_th_boost_amp_cap').value) || 0,
                boost_confidence_cap: parseFloat(document.getElementById('fd_th_boost_conf_cap').value) || 0,
                ema_alpha: parseFloat(document.getElementById('fd_th_ema_alpha').value) || 0,
                heatmap_coarse_weight: parseFloat(document.getElementById('fd_th_coarse_wt').value) || 0
            };
        }

        function applyFdSettings() {
            const setName = document.getElementById('fd_model_set').value;
            const set = window.fdCurrentSet;
            const settings = {
                enabled: document.getElementById('fd_enabled').checked,
                model_set: setName,
                cnn_enabled: !!(set && set.has_cnn),
                proto_enabled: !!(set && set.has_protonet),
                multi_enabled: !!(set && set.has_multiclass),
                strategy: document.getElementById('fd_strategy').value,
                heatmap_enabled: document.getElementById('fd_heatmap').checked,
                beep_pattern: parseInt(document.getElementById('fd_beep_pattern').value) || 0,
                interval: parseInt(document.getElementById('fd_interval').value) || 5,
                verify_interval: parseInt(document.getElementById('fd_verify_interval').value) || 2
            };

            // Build threshold config for this set
            if (setName && window.fdCurrentSet && Object.keys(window.fdCurrentSet.profiles || {}).length > 0) {
                const custom = document.getElementById('fd_custom').checked;
                const thVals = getThresholdValues();
                settings.thresholds = {};
                settings.thresholds[setName] = {
                    mode: custom ? 'custom' : 'profile',
                    profile: document.getElementById('fd_profile').value,
                    ...thVals
                };
            }

            const msgEl = document.getElementById('fd-status-msg');

            fetch('/api/fault_detect/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'ok') {
                    if (msgEl) {
                        msgEl.textContent = 'Settings saved';
                        msgEl.style.color = '#4a4';
                        setTimeout(() => { msgEl.textContent = ''; }, 3000);
                    }
                } else {
                    if (msgEl) {
                        msgEl.textContent = 'Error: ' + (data.error || 'unknown');
                        msgEl.style.color = '#f44';
                    }
                }
            })
            .catch(err => {
                if (msgEl) {
                    msgEl.textContent = 'Error: ' + err;
                    msgEl.style.color = '#f44';
                }
            });
        }

        // Initialize fault detection UI
        (function() {
            // Hide FD sections entirely if not installed
            const fdInstalled = '$fd_installed' === 'true';
            if (!fdInstalled) {
                const s1 = document.getElementById('fd-status-section');
                const s2 = document.getElementById('fd-config-section');
                const s3 = document.getElementById('proto-section');
                if (s1) s1.style.display = 'none';
                if (s2) s2.style.display = 'none';
                if (s3) s3.style.display = 'none';
                return;
            }
            protoRefresh();
            updateFdVisibility();
            // Set strategy from template
            const strat = '$fd_strategy';
            if (strat && strat !== '$' + 'fd_strategy') {
                const sel = document.getElementById('fd_strategy');
                if (sel) sel.value = strat;
            }
            // Set beep pattern from template
            const bp = '$fd_beep_pattern';
            if (bp && bp !== '$' + 'fd_beep_pattern') {
                const bpSel = document.getElementById('fd_beep_pattern');
                if (bpSel) bpSel.value = bp;
            }
            // Load model sets
            loadFdSets();

            // Setup wizard badge
            (function() {
                const st = parseInt('$fd_setup_status') || 0;
                const ts = parseInt('$fd_setup_timestamp') || 0;
                const badge = document.getElementById('fd-setup-badge');
                const last = document.getElementById('fd-setup-last');
                if (badge) {
                    if (st === 2) {
                        badge.textContent = 'Calibrated';
                        badge.style.background = '#1a5c2e';
                        badge.style.color = '#4CAF50';
                    } else if (st === 1) {
                        badge.textContent = 'In Progress';
                        badge.style.background = '#5c4a1a';
                        badge.style.color = '#f0ad4e';
                    } else {
                        badge.textContent = 'Not Configured';
                        badge.style.background = '#444';
                        badge.style.color = '#999';
                    }
                }
                if (last && ts > 0) {
                    const d = new Date(ts * 1000);
                    last.textContent = 'Last calibrated: ' + d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
                }
            })();
        })();
        // ============================================================
        // Prototype Management
        // ============================================================
        let protoComputeTimer = null;
        let protoDlTimer = null;

        function protoRefresh() {
            protoLoadDatasets();
            protoLoadSets();
            /* Resume progress display if computation was already running */
            fetch('/api/proto/compute/status').then(r => r.json()).then(data => {
                if (data.state === 'running' || data.state === 'saving') {
                    document.getElementById('proto-compute-status').style.display = 'block';
                    document.getElementById('proto-cancel-btn').style.display = 'inline-block';
                    protoComputeTimer = setInterval(protoCheckComputeStatus, 2000);
                    protoCheckComputeStatus();
                } else if (data.state === 'done' && data.elapsed_s > 0) {
                    /* Show last completed results */
                    document.getElementById('proto-compute-status').style.display = 'block';
                    protoCheckComputeStatus();
                }
            }).catch(() => {});
        }

        function protoLoadDatasets() {
            fetch('/api/proto/datasets').then(r => r.json()).then(data => {
                const el = document.getElementById('proto-datasets-list');
                const dsel = document.getElementById('proto-compute-dataset');
                const csel = document.getElementById('proto-capture-dataset');
                if (!data.datasets || data.datasets.length === 0) {
                    el.innerHTML = '<div style="color:#888;">No datasets. Download or create one.</div>';
                    dsel.innerHTML = '';
                    csel.innerHTML = '';
                    return;
                }
                let html = '';
                dsel.innerHTML = '';
                csel.innerHTML = '';
                data.datasets.forEach(ds => {
                    const sizeMB = ds.size_mb ? ds.size_mb.toFixed(1) : '?';
                    html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:5px;padding:6px 10px;background:#2a2a2a;border:1px solid #444;border-radius:4px;">
                        <span style="flex:1;"><b>${ds.name}</b> &mdash; ${ds.n_failure}f / ${ds.n_success}s (${sizeMB} MB)</span>
                        <button onclick="protoDeleteDataset('${ds.name}')" style="font-size:11px;padding:2px 8px;background:#633;">Del</button>
                    </div>`;
                    const opt1 = document.createElement('option');
                    opt1.value = ds.name; opt1.textContent = `${ds.name} (${ds.n_failure}f/${ds.n_success}s)`;
                    dsel.appendChild(opt1);
                    const opt2 = opt1.cloneNode(true);
                    csel.appendChild(opt2);
                });
                el.innerHTML = html;
            }).catch(() => {});
        }

        function protoLoadSets() {
            fetch('/api/proto/sets').then(r => r.json()).then(data => {
                const el = document.getElementById('proto-sets-list');
                if (!data.sets || data.sets.length === 0) {
                    el.innerHTML = '<div style="color:#888;">No prototype sets computed yet.</div>';
                    return;
                }
                let html = '';
                const labels = ['Class', 'Fine', 'Coarse'];
                const sorted = data.sets.slice().sort((a, b) => (b.is_active ? 1 : 0) - (a.is_active ? 1 : 0));
                sorted.forEach(s => {
                    const active = s.is_active;
                    const border = active ? '1px solid #4CAF50' : '1px solid #444';
                    const badge = active ? '<span style="color:#4CAF50;font-size:11px;font-weight:bold;margin-left:6px;">ACTIVE</span>' : '';
                    let marginsHtml = s.margins.map((m, i) => {
                        const color = m > 0.5 ? '#4CAF50' : m > 0.1 ? '#f0ad4e' : '#d9534f';
                        return `<span style="color:${color}">${labels[i]}: ${m.toFixed(3)}</span>`;
                    }).join(' &nbsp; ');
                    html += `<div style="padding:6px 10px;margin-bottom:5px;background:#2a2a2a;border:${border};border-radius:4px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span style="flex:1;"><b>${s.name}</b>${badge}</span>
                            ${!active ? `<button onclick="protoActivateSet('${s.name}')" style="font-size:11px;padding:2px 8px;">Activate</button>` : ''}
                            <button onclick="protoDeleteSet('${s.name}')" style="font-size:11px;padding:2px 8px;background:#633;">Del</button>
                        </div>
                        <div style="font-size:11px;color:#aaa;margin-top:3px;">
                            ${s.source_dataset ? 'From: ' + s.source_dataset + ' &mdash; ' : ''}${s.n_failure}f/${s.n_success}s
                        </div>
                        <div style="font-size:11px;margin-top:3px;">${marginsHtml}</div>
                    </div>`;
                });
                el.innerHTML = html;
            }).catch(() => {});
        }

        function protoDownloadDataset() {
            const btn = document.getElementById('proto-dl-btn');
            btn.disabled = true;
            fetch('/api/proto/datasets/download', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({})
            }).then(r => r.json()).then(data => {
                if (data.ok) {
                    document.getElementById('proto-dl-status').style.display = 'block';
                    protoDlTimer = setInterval(protoCheckDlStatus, 2000);
                } else {
                    btn.disabled = false;
                    alert(data.message || 'Download failed');
                }
            }).catch(e => { btn.disabled = false; alert('Error: ' + e); });
        }

        function protoCheckDlStatus() {
            fetch('/api/proto/datasets/download/status').then(r => r.json()).then(data => {
                const bar = document.getElementById('proto-dl-bar');
                const text = document.getElementById('proto-dl-text');
                if (data.state === 'running') {
                    const mb = (data.downloaded_bytes / 1048576).toFixed(1);
                    bar.style.width = '50%';
                    text.textContent = `Downloading... ${mb} MB`;
                } else if (data.state === 'extracting') {
                    bar.style.width = '80%';
                    text.textContent = 'Extracting...';
                } else if (data.state === 'done') {
                    bar.style.width = '100%';
                    text.textContent = 'Download complete!';
                    text.style.color = '#4CAF50';
                    clearInterval(protoDlTimer);
                    document.getElementById('proto-dl-btn').disabled = false;
                    setTimeout(() => {
                        document.getElementById('proto-dl-status').style.display = 'none';
                        protoLoadDatasets();
                    }, 2000);
                } else if (data.state === 'error') {
                    bar.style.width = '100%';
                    bar.style.background = '#d9534f';
                    text.textContent = 'Error: ' + (data.error || 'unknown');
                    text.style.color = '#d9534f';
                    clearInterval(protoDlTimer);
                    document.getElementById('proto-dl-btn').disabled = false;
                }
            });
        }

        function protoCreateDataset() {
            const name = prompt('Dataset name (no spaces/special chars):');
            if (!name) return;
            fetch('/api/proto/datasets/create', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({name: name})
            }).then(r => r.json()).then(() => protoLoadDatasets());
        }

        function protoDeleteDataset(name) {
            if (!confirm(`Delete dataset "${name}" and all images?`)) return;
            fetch(`/api/proto/datasets/delete/${name}`, {method:'POST'})
                .then(r => r.json()).then(() => protoLoadDatasets());
        }

        function protoStartCompute(incremental) {
            const dataset = document.getElementById('proto-compute-dataset').value;
            const setName = document.getElementById('proto-compute-setname').value.trim();
            if (!dataset) { alert('Select a dataset'); return; }
            if (!setName) { alert('Enter a set name'); return; }
            const url = incremental ? '/api/proto/compute/incremental' : '/api/proto/compute';
            fetch(url, {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({dataset: dataset, set_name: setName})
            }).then(r => r.json()).then(data => {
                if (data.ok) {
                    document.getElementById('proto-compute-status').style.display = 'block';
                    document.getElementById('proto-compute-results').style.display = 'none';
                    document.getElementById('proto-cancel-btn').style.display = 'inline-block';
                    protoComputeTimer = setInterval(protoCheckComputeStatus, 2000);
                } else {
                    alert(data.message || 'Failed to start computation');
                }
            }).catch(e => alert('Error: ' + e));
        }

        function protoCancelCompute() {
            fetch('/api/proto/compute/cancel', {method:'POST'});
        }

        function protoFormatTime(totalSec) {
            if (totalSec < 0) totalSec = 0;
            const h = Math.floor(totalSec / 3600);
            const m = Math.floor((totalSec % 3600) / 60);
            const s = Math.floor(totalSec % 60);
            if (h > 0) return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
            return `${m}:${String(s).padStart(2,'0')}`;
        }

        function protoCheckComputeStatus() {
            fetch('/api/proto/compute/status').then(r => r.json()).then(data => {
                const bar = document.getElementById('proto-compute-bar');
                const text = document.getElementById('proto-compute-text');
                const results = document.getElementById('proto-compute-results');
                const cancelBtn = document.getElementById('proto-cancel-btn');

                if (data.state === 'running' || data.state === 'saving') {
                    const pct = data.total_all > 0 ? Math.round(100 * data.total_processed / data.total_all) : 0;
                    bar.style.width = pct + '%';
                    bar.style.background = '#4a9eff';
                    const cls = data.current_class === 0 ? 'failure' : 'success';
                    const remaining = data.estimated_total_s > 0 ? data.estimated_total_s - data.elapsed_s : 0;
                    const eta = data.estimated_total_s > 0 ? ` (ETA: ${protoFormatTime(remaining)})` : '';
                    text.textContent = `${data.model_name || '?'} [${cls}] ${data.images_processed}/${data.images_total}  ${pct}% ${protoFormatTime(data.elapsed_s)}${eta}`;
                } else if (data.state === 'done') {
                    bar.style.width = '100%';
                    bar.style.background = '#4CAF50';
                    text.textContent = `Done in ${protoFormatTime(data.elapsed_s)}`;
                    clearInterval(protoComputeTimer);
                    cancelBtn.style.display = 'none';

                    const labels = ['Classification', 'Spatial Fine', 'Spatial Coarse'];
                    let rHtml = '<b>Results:</b> ';
                    if (data.margins) {
                        data.margins.forEach((m, i) => {
                            const color = m > 0.5 ? '#4CAF50' : m > 0.1 ? '#f0ad4e' : '#d9534f';
                            rHtml += `<span style="color:${color}">${labels[i]}: ${m.toFixed(3)}</span> &nbsp; `;
                        });
                    }
                    results.innerHTML = rHtml;
                    results.style.display = 'block';
                    protoLoadSets();
                } else if (data.state === 'error' || data.state === 'cancelled') {
                    bar.style.width = '100%';
                    bar.style.background = '#d9534f';
                    text.textContent = data.state === 'cancelled' ? 'Cancelled' : 'Error: ' + (data.error || 'unknown');
                    clearInterval(protoComputeTimer);
                    cancelBtn.style.display = 'none';
                } else if (data.state === 'idle') {
                    clearInterval(protoComputeTimer);
                    cancelBtn.style.display = 'none';
                }
            });
        }

        function protoActivateSet(name) {
            fetch('/api/proto/sets/activate', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({name: name})
            }).then(r => r.json()).then(data => {
                if (data.ok) protoLoadSets();
                else alert(data.message || 'Activation failed');
            });
        }

        function protoDeleteSet(name) {
            if (!confirm(`Delete prototype set "${name}"?`)) return;
            fetch(`/api/proto/sets/delete/${name}`, {method:'POST'})
                .then(r => r.json()).then(() => protoLoadSets());
        }

        function protoSaveFrame(cls) {
            const dataset = document.getElementById('proto-capture-dataset').value;
            if (!dataset) { alert('Select a dataset first'); return; }
            fetch('/api/proto/datasets/save_frame', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({dataset: dataset, class: cls})
            }).then(r => r.json()).then(data => {
                const msg = document.getElementById('proto-capture-msg');
                if (data.ok) {
                    const kb = (data.size / 1024).toFixed(1);
                    msg.textContent = `Saved ${cls} frame (${kb} KB)`;
                    msg.style.color = '#4CAF50';
                    protoLoadDatasets();
                } else {
                    msg.textContent = data.message || 'Save failed';
                    msg.style.color = '#d9534f';
                }
                setTimeout(() => { msg.textContent = ''; }, 3000);
            });
        }

    </script>
</body>
</html>
